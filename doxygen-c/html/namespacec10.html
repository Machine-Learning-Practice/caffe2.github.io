<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Caffe2 - C++ API: c10 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="/static/favicon.png" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo" width="56"><a href="/"><img alt="Logo" src="Caffe2-with-name-55-tall.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Caffe2 - C++ API
   </div>
   <div id="projectbrief">A deep learning, cross platform ML framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="/doxygen-c/html/classes.html"><span>C++&#160;API</span></a></li>
      <li><a href="/doxygen-python/html/annotated.html"><span>Python&#160;API</span></a></li>
      <li><a href="https://github.com/caffe2/caffe2"><span>GitHub</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">c10 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>To register your own kernel for an operator, do in one (!) cpp file: C10_REGISTER_KERNEL(OperatorHandle) .kernel&lt;decltype(&amp;kernel_func), &amp;kernel_func&gt;() .dispatchKey(dispatch_key);.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacec10_1_1enforce__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10_1_1enforce__detail.html">enforce_detail</a></td></tr>
<tr class="memdesc:namespacec10_1_1enforce__detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rich logging messages. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1___copy_bytes_function_registerer.html">_CopyBytesFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1__fake__type.html">_fake_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_alias_info.html">AliasInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class <a class="el" href="classc10_1_1_alias_info.html" title="class AliasInfo ">AliasInfo</a>  <a href="classc10_1_1_alias_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_aligned_char_array.html">AlignedCharArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for building an aligned character array type.  <a href="structc10_1_1_aligned_char_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_aligned_char_array_union.html">AlignedCharArrayUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This union template exposes a suitably aligned and sized character array member which can hold elements of any of up to ten types.  <a href="structc10_1_1_aligned_char_array_union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_allocator.html">Allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_allocator_registerer.html">AllocatorRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_argument.html">Argument</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_array_ref.html">ArrayRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classc10_1_1_array_ref.html" title="ArrayRef - Represent a constant reference to an array (0 or more elements consecutively in memory)...">ArrayRef</a> - Represent a constant reference to an array (0 or more elements consecutively in memory), i.e.  <a href="classc10_1_1_array_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_autograd_meta_interface.html">AutogradMetaInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_autograd_zero_tensor_type.html">AutogradZeroTensorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1bad__optional__access.html">bad_optional_access</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_bool_type.html">BoolType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_c10_flag_parser.html">C10FlagParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_c10_tensor.html">C10Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a minimal <a class="el" href="struct_tensor.html">Tensor</a> class for use in <a class="el" href="namespacec10.html" title="To register your own kernel for an operator, do in one (!) cpp file: C10_REGISTER_KERNEL(OperatorHand...">c10</a> code.  <a href="classc10_1_1_c10_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_class_type.html">ClassType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_complete_tensor_type.html">CompleteTensorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_complex_half.html">ComplexHalf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1constexpr__optional__base.html">constexpr_optional_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionc10_1_1constexpr__storage__t.html">constexpr_storage_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_converter.html">Converter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_converter_3_01_to_00_01std_1_1complex_3_01_from_v_01_4_00_01typename_01std_1_1enabf989a20bcbfc8c1e71820ac8a739757b.html">Converter&lt; To, std::complex&lt; FromV &gt;, typename std::enable_if&lt; c10::guts::negation&lt; is_complex_t&lt; To &gt; &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_data_ptr.html">DataPtr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_default_c_p_u_allocator.html">DefaultCPUAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_default_tensor_options.html">DefaultTensorOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>, but all fields are guaranteed to be filled.  <a href="structc10_1_1_default_tensor_options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_device.html">Device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a a compute device on which a tensor is located.  <a href="structc10_1_1_device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_device_guard.html">DeviceGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII guard that sets a certain default device in its constructor, and changes it back to the device that was originally active upon destruction.  <a href="classc10_1_1_device_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_device_obj_type.html">DeviceObjType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_dict_type.html">DictType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_dimensioned_tensor_type.html">DimensionedTensorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_dispatcher.html">Dispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Top-level dispatch interface for dispatching via the dynamic dispatcher.  <a href="classc10_1_1_dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_dispatch_table.html">DispatchTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Per-operator dispatch table.  <a href="classc10_1_1_dispatch_table.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_dispatch_table_entry.html">DispatchTableEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dispatch table stores a pointer to a kernel function and a pointer to a function initializing a cache for the kernel.  <a href="structc10_1_1_dispatch_table_entry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary ATen error class.  <a href="classc10_1_1_error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_float_type.html">FloatType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_function_schema.html">FunctionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_future_type.html">FutureType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_generator_type.html">GeneratorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_half.html">Half</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_id_wrapper.html">IdWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template simplifies generation of simple classes that wrap an id in a typesafe way.  <a href="classc10_1_1_id_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1in__place__t.html">in_place_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_index_error.html">IndexError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_inefficient_std_function_context.html">InefficientStdFunctionContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_interned_strings.html">InternedStrings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1intrusive__ptr__target.html">intrusive_ptr_target</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">intrusive_ptr&lt;T&gt; is an alternative to shared_ptr&lt;T&gt; that has better performance because it does the refcounting intrusively (i.e.  <a href="classc10_1_1intrusive__ptr__target.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_int_type.html">IntType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1is__complex__t.html">is_complex_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1is__complex__t_3_01_complex_half_01_4.html">is_complex_t&lt; ComplexHalf &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1is__complex__t_3_01std_1_1complex_3_01_t_01_4_01_4.html">is_complex_t&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1ivalue.html">ivalue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_i_value.html">IValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_kernel_cache.html">KernelCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> kernel can keep around a cache to have better performance when it's called multiple times.  <a href="classc10_1_1_kernel_cache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_kernel_registrar.html">KernelRegistrar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class which, on construction, registers an operator in the dispatch table.  <a href="classc10_1_1_kernel_registrar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_kernel_registration_builder.html">KernelRegistrationBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for building a <a class="el" href="classc10_1_1_kernel_registrar.html" title="Class which, on construction, registers an operator in the dispatch table. ">KernelRegistrar</a>.  <a href="classc10_1_1_kernel_registration_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_left_right.html">LeftRight</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_list_type.html">ListType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_logger_voidify.html">LoggerVoidify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_match_type_return.html">MatchTypeReturn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_memory_allocation_reporter.html">MemoryAllocationReporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_message_logger.html">MessageLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_none_type.html">NoneType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_number_type.html">NumberType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_operator_handle.html">OperatorHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a handle to an operator schema registered with the dispatcher.  <a href="classc10_1_1_operator_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_op_kernel.html">OpKernel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an operator kernel, i.e.  <a href="classc10_1_1_op_kernel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_op_registration_listener.html">OpRegistrationListener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement this interface and register your instance with the dispatcher to get notified when operators are registered or deregistered with the dispatcher.  <a href="classc10_1_1_op_registration_listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1optional.html">optional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1optional_3_01_t_01_6_01_4.html">optional&lt; T &amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1optional_3_01_t_01_6_6_01_4.html">optional&lt; T &amp;&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1optional__base.html">optional_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_optional_device_guard.html">OptionalDeviceGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> <a class="el" href="classc10_1_1_optional_device_guard.html" title="A OptionalDeviceGuard is an RAII class that sets a device to some value on initialization, and resets the device to its original value on destruction. ">OptionalDeviceGuard</a> is an RAII class that sets a device to some value on initialization, and resets the device to its original value on destruction.  <a href="classc10_1_1_optional_device_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_optional_stream_guard.html">OptionalStreamGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="structc10_1_1_optional_stream_guard.html" title="An OptionalStreamGuard is an RAII class that sets a device to some value on initialization, and resets the device to its original value on destruction. ">OptionalStreamGuard</a> is an RAII class that sets a device to some value on initialization, and resets the device to its original value on destruction.  <a href="structc10_1_1_optional_stream_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_optional_type.html">OptionalType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_placement_delete_context.html">PlacementDeleteContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_registerer.html">Registerer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> template class that allows one to register classes by keys.  <a href="classc10_1_1_registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_scalar.html">Scalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classc10_1_1_scalar.html" title="Scalar represents a 0-dimensional tensor which contains a single element. ">Scalar</a> represents a 0-dimensional tensor which contains a single element.  <a href="classc10_1_1_scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1scalar__value__type.html">scalar_value_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1scalar__value__type_3_01_complex_half_01_4.html">scalar_value_type&lt; ComplexHalf &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1scalar__value__type_3_01std_1_1complex_3_01_t_01_4_01_4.html">scalar_value_type&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_single_element_type.html">SingleElementType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_small_vector.html">SmallVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a 'vector' (really, a variable-sized array), optimized for the case when the array is small.  <a href="classc10_1_1_small_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_small_vector_base.html">SmallVectorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is all the non-templated stuff common to all SmallVectors.  <a href="classc10_1_1_small_vector_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_small_vector_impl.html">SmallVectorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class consists of common code factored out of the <a class="el" href="classc10_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small...">SmallVector</a> class to reduce code duplication based on the <a class="el" href="classc10_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small...">SmallVector</a> 'N' template parameter.  <a href="classc10_1_1_small_vector_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_small_vector_storage.html">SmallVectorStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structc10_1_1_storage.html">Storage</a> for the <a class="el" href="classc10_1_1_small_vector.html" title="This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the array is small...">SmallVector</a> elements which aren't contained in <a class="el" href="classc10_1_1_small_vector_template_common.html" title="This is the part of SmallVectorTemplateBase which does not depend on whether the type T is a POD...">SmallVectorTemplateCommon</a>.  <a href="structc10_1_1_small_vector_storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_small_vector_storage_3_01_t_00_010_01_4.html">SmallVectorStorage&lt; T, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_small_vector_storage_3_01_t_00_011_01_4.html">SmallVectorStorage&lt; T, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_small_vector_template_base.html">SmallVectorTemplateBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classc10_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;isPodLike = false&gt; - This is where we put method implementations that are des...">SmallVectorTemplateBase</a>&lt;isPodLike = false&gt; - This is where we put method implementations that are designed to work with non-POD-like <a class="el" href="struct_t.html">T</a>'s.  <a href="classc10_1_1_small_vector_template_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_small_vector_template_base_3_01_t_00_01true_01_4.html">SmallVectorTemplateBase&lt; T, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classc10_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;isPodLike = false&gt; - This is where we put method implementations that are des...">SmallVectorTemplateBase</a>&lt;isPodLike = true&gt; - This is where we put method implementations that are designed to work with POD-like <a class="el" href="struct_t.html">T</a>'s.  <a href="classc10_1_1_small_vector_template_base_3_01_t_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_small_vector_template_common.html">SmallVectorTemplateCommon</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the part of <a class="el" href="classc10_1_1_small_vector_template_base.html" title="SmallVectorTemplateBase&lt;isPodLike = false&gt; - This is where we put method implementations that are des...">SmallVectorTemplateBase</a> which does not depend on whether the type <a class="el" href="struct_t.html">T</a> is a POD.  <a href="classc10_1_1_small_vector_template_common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_source_location.html">SourceLocation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location in source code (for debugging).  <a href="structc10_1_1_source_location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_storage.html">Storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionc10_1_1storage__t.html">storage_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_storage_impl.html">StorageImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> stream is a software mechanism used to synchronize launched kernels without requiring explicit synchronizations between kernels.  <a href="classc10_1_1_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_stream_guard.html">StreamGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> <a class="el" href="structc10_1_1_stream_guard.html" title="A StreamGuard is an RAII class that changes the current device to the device corresponding to some st...">StreamGuard</a> is an RAII class that changes the current device to the device corresponding to some stream, and changes the default stream on that device to be this stream.  <a href="structc10_1_1_stream_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_string_type.html">StringType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_symbol.html">Symbol</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_task_thread_pool.html">TaskThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_task_thread_pool_base.html">TaskThreadPoolBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_temp_file.html">TempFile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_tensor_impl.html">TensorImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The low-level representation of a tensor, which contains a pointer to a storage (which contains the actual data) and metadata (e.g., sizes and strides) describing this particular view of the data as a tensor.  <a href="structc10_1_1_tensor_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_tensor_type.html">TensorType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_tensor_type_id.html">TensorTypeId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic type ID of a <a class="el" href="struct_tensor.html">Tensor</a> argument.  <a href="classc10_1_1_tensor_type_id.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_tensor_type_id_creator.html">TensorTypeIdCreator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_tensor_type_id_registrar.html">TensorTypeIdRegistrar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_tensor_type_id_registry.html">TensorTypeIdRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_tensor_type_ids.html">TensorTypeIds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_thread_pool.html">ThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1trivial__init__t.html">trivial_init_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_tuple_type.html">TupleType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_type.html">Type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_undefined_tensor_impl.html">UndefinedTensorImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structc10_1_1_var_type.html">VarType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1_warning.html">Warning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab0b0cc3d46867de8f1fc3eb5b2b1f05b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#ab0b0cc3d46867de8f1fc3eb5b2b1f05b">KernelCacheCreatorFunction</a>) = std::unique_ptr&lt; <a class="el" href="classc10_1_1_kernel_cache.html">c10::KernelCache</a> &gt;(</td></tr>
<tr class="memdesc:ab0b0cc3d46867de8f1fc3eb5b2b1f05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a user-supplied function to initialize the kernel cache.  <a href="#ab0b0cc3d46867de8f1fc3eb5b2b1f05b">More...</a><br /></td></tr>
<tr class="separator:ab0b0cc3d46867de8f1fc3eb5b2b1f05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa8bf00f4b6529e9506c3a0e16725b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aa8bf00f4b6529e9506c3a0e16725b9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Stack</b> = torch::jit::Stack</td></tr>
<tr class="separator:a7aa8bf00f4b6529e9506c3a0e16725b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cf2f99dcc955e3b841db692c5b7102"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a86cf2f99dcc955e3b841db692c5b7102">KernelFunction</a> = void(Stack *, <a class="el" href="classc10_1_1_kernel_cache.html">KernelCache</a> *cache)</td></tr>
<tr class="memdesc:a86cf2f99dcc955e3b841db692c5b7102"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the basic ABI for any kernel call.  <a href="#a86cf2f99dcc955e3b841db692c5b7102">More...</a><br /></td></tr>
<tr class="separator:a86cf2f99dcc955e3b841db692c5b7102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a97460559727aba8cdf709ecafa386"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09a97460559727aba8cdf709ecafa386"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>unique_t</b> = uint32_t</td></tr>
<tr class="separator:a09a97460559727aba8cdf709ecafa386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae084b829fa15992034037bfc946ff9fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae084b829fa15992034037bfc946ff9fa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_type.html">Type</a> &gt;</td></tr>
<tr class="separator:ae084b829fa15992034037bfc946ff9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad697bfac8a2c530b59d41e0c013f7a1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad697bfac8a2c530b59d41e0c013f7a1a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>OptionalTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_optional_type.html">OptionalType</a> &gt;</td></tr>
<tr class="separator:ad697bfac8a2c530b59d41e0c013f7a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4386ed898b2c4db5bf4e5e27a68b3426"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4386ed898b2c4db5bf4e5e27a68b3426"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TensorTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_tensor_type.html">TensorType</a> &gt;</td></tr>
<tr class="separator:a4386ed898b2c4db5bf4e5e27a68b3426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c26ed9ee87f4658df9ff386f976436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98c26ed9ee87f4658df9ff386f976436"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AutogradZeroTensorTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_autograd_zero_tensor_type.html">AutogradZeroTensorType</a> &gt;</td></tr>
<tr class="separator:a98c26ed9ee87f4658df9ff386f976436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de61a4184e57ddf41ce564237212cc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6de61a4184e57ddf41ce564237212cc4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DimensionedTensorTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_dimensioned_tensor_type.html">DimensionedTensorType</a> &gt;</td></tr>
<tr class="separator:a6de61a4184e57ddf41ce564237212cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6e50ca4bc226d48b6af83694e8c544"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c6e50ca4bc226d48b6af83694e8c544"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CompleteTensorTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_complete_tensor_type.html">CompleteTensorType</a> &gt;</td></tr>
<tr class="separator:a5c6e50ca4bc226d48b6af83694e8c544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426e32f27b7dfcf5dff04039bb3625d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a426e32f27b7dfcf5dff04039bb3625d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ListTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_list_type.html">ListType</a> &gt;</td></tr>
<tr class="separator:a426e32f27b7dfcf5dff04039bb3625d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639caa2cb22456a3a3f9a0ef85268447"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a639caa2cb22456a3a3f9a0ef85268447"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DictTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_dict_type.html">DictType</a> &gt;</td></tr>
<tr class="separator:a639caa2cb22456a3a3f9a0ef85268447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13a3b5713f7044ca00082fbefbdf8c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac13a3b5713f7044ca00082fbefbdf8c2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FutureTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_future_type.html">FutureType</a> &gt;</td></tr>
<tr class="separator:ac13a3b5713f7044ca00082fbefbdf8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfd1b30d2a10049a5029f30407f0022"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bfd1b30d2a10049a5029f30407f0022"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TupleTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_tuple_type.html">TupleType</a> &gt;</td></tr>
<tr class="separator:a2bfd1b30d2a10049a5029f30407f0022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4dc195bbf3a1e797a7b35c48682af9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d4dc195bbf3a1e797a7b35c48682af9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>OptNameList</b> = <a class="el" href="classc10_1_1optional.html">c10::optional</a>&lt; std::vector&lt; std::string &gt;&gt;</td></tr>
<tr class="separator:a3d4dc195bbf3a1e797a7b35c48682af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5432332bf26a4af1f269d3f2748698"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d5432332bf26a4af1f269d3f2748698"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NumberTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_number_type.html">NumberType</a> &gt;</td></tr>
<tr class="separator:a2d5432332bf26a4af1f269d3f2748698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974bdee78971ed385a6c0f6fea9a3f33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a974bdee78971ed385a6c0f6fea9a3f33"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FloatTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_float_type.html">FloatType</a> &gt;</td></tr>
<tr class="separator:a974bdee78971ed385a6c0f6fea9a3f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25a3f249c9f923d91cf80c332a38d8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae25a3f249c9f923d91cf80c332a38d8f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IntTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_int_type.html">IntType</a> &gt;</td></tr>
<tr class="separator:ae25a3f249c9f923d91cf80c332a38d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c9ea07fe3200a16ecae09ed6e2478e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6c9ea07fe3200a16ecae09ed6e2478e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BoolTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_bool_type.html">BoolType</a> &gt;</td></tr>
<tr class="separator:ac6c9ea07fe3200a16ecae09ed6e2478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d25dd40ff27663701895d81ada38ac0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d25dd40ff27663701895d81ada38ac0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>StringTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_string_type.html">StringType</a> &gt;</td></tr>
<tr class="separator:a5d25dd40ff27663701895d81ada38ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63355a3f292193f6fd3ac7931ab7efee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63355a3f292193f6fd3ac7931ab7efee"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NoneTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_none_type.html">NoneType</a> &gt;</td></tr>
<tr class="separator:a63355a3f292193f6fd3ac7931ab7efee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133905010f95f19af442259e87dcfb68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a133905010f95f19af442259e87dcfb68"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GeneratorTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_generator_type.html">GeneratorType</a> &gt;</td></tr>
<tr class="separator:a133905010f95f19af442259e87dcfb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f976db56e5b9fd27869cca0e7d6c131"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f976db56e5b9fd27869cca0e7d6c131"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceObjTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_device_obj_type.html">DeviceObjType</a> &gt;</td></tr>
<tr class="separator:a8f976db56e5b9fd27869cca0e7d6c131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e117b1d7f5b76be6f4260d09565e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a526e117b1d7f5b76be6f4260d09565e7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>VarTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_var_type.html">VarType</a> &gt;</td></tr>
<tr class="separator:a526e117b1d7f5b76be6f4260d09565e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0549d2c856b21b7c700da90a2fd32818"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0549d2c856b21b7c700da90a2fd32818"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>TypeEnv</b> = std::unordered_map&lt; std::string, TypePtr &gt;</td></tr>
<tr class="separator:a0549d2c856b21b7c700da90a2fd32818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa910f927ef62633d568ecb3ec2f7c77e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa910f927ef62633d568ecb3ec2f7c77e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ClassTypePtr</b> = std::shared_ptr&lt; <a class="el" href="structc10_1_1_class_type.html">ClassType</a> &gt;</td></tr>
<tr class="separator:aa910f927ef62633d568ecb3ec2f7c77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b38fd780fe639d3959fa533207dba6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68b38fd780fe639d3959fa533207dba6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CopyBytesFunction</b> = void(*)(size_t nbytes, const void *src, <a class="el" href="structc10_1_1_device.html">Device</a> src_device, void *dst, <a class="el" href="structc10_1_1_device.html">Device</a> dst_device)</td></tr>
<tr class="separator:a68b38fd780fe639d3959fa533207dba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b01b108ea61f9d702bf96d4d4726811"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b01b108ea61f9d702bf96d4d4726811"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryDeleter</b> = void(*)(void *)</td></tr>
<tr class="separator:a3b01b108ea61f9d702bf96d4d4726811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c3bec19efab8293c355543d1d3a230"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a42c3bec19efab8293c355543d1d3a230">DeviceIndex</a> = int16_t</td></tr>
<tr class="memdesc:a42c3bec19efab8293c355543d1d3a230"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index representing a specific device; e.g., the 1 in GPU 1.  <a href="#a42c3bec19efab8293c355543d1d3a230">More...</a><br /></td></tr>
<tr class="separator:a42c3bec19efab8293c355543d1d3a230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303110250c2998ead3a7f1b0638158cb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a303110250c2998ead3a7f1b0638158cb">StreamId</a> = int32_t</td></tr>
<tr class="memdesc:a303110250c2998ead3a7f1b0638158cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index representing a specific stream.  <a href="#a303110250c2998ead3a7f1b0638158cb">More...</a><br /></td></tr>
<tr class="separator:a303110250c2998ead3a7f1b0638158cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b081479f7f61da4f51f226e36d41f71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b081479f7f61da4f51f226e36d41f71"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PlacementDtor</b> = void(*)(void *, size_t)</td></tr>
<tr class="separator:a3b081479f7f61da4f51f226e36d41f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c46d838a1de023ea17ade42f417669"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2c46d838a1de023ea17ade42f417669"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IntArrayRef</b> = <a class="el" href="classc10_1_1_array_ref.html">ArrayRef</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:ae2c46d838a1de023ea17ade42f417669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb9c68e717f360e78510ef3497f86ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeb9c68e717f360e78510ef3497f86ca"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEPRECATED_USING</b> = <a class="el" href="classc10_1_1_array_ref.html">ArrayRef</a>&lt; int64_t &gt;</td></tr>
<tr class="separator:adeb9c68e717f360e78510ef3497f86ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14a83212220e66d308f23e78c4fbae7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae14a83212220e66d308f23e78c4fbae7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>weak_intrusive_ptr_target</b> = <a class="el" href="classc10_1_1intrusive__ptr__target.html">intrusive_ptr_target</a></td></tr>
<tr class="separator:ae14a83212220e66d308f23e78c4fbae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1627147226bd0cafb0e075e47ae2438f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1627147226bd0cafb0e075e47ae2438f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EnforceNotMet</b> = ::<a class="el" href="classc10_1_1_error.html">c10::Error</a></td></tr>
<tr class="separator:a1627147226bd0cafb0e075e47ae2438f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba96871964bb5762d5f7cb235e28857f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aba96871964bb5762d5f7cb235e28857f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aba96871964bb5762d5f7cb235e28857f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OptionalBase</b> = typename std::conditional&lt; std::is_trivially_destructible&lt; <a class="el" href="struct_t.html">T</a> &gt;::value, <a class="el" href="structc10_1_1constexpr__optional__base.html">constexpr_optional_base</a>&lt; typename std::remove_const&lt; <a class="el" href="struct_t.html">T</a> &gt;::type &gt;, <a class="el" href="structc10_1_1optional__base.html">optional_base</a>&lt; typename std::remove_const&lt; <a class="el" href="struct_t.html">T</a> &gt;::type &gt;&gt;::type</td></tr>
<tr class="separator:aba96871964bb5762d5f7cb235e28857f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f28bb7e31060311d9de2c1ccb02e54c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f28bb7e31060311d9de2c1ccb02e54c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>DeleterFnPtr</b> = void(*)(void *)</td></tr>
<tr class="separator:a3f28bb7e31060311d9de2c1ccb02e54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0292c5e8804631b2f755dbf78cc8f3dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0292c5e8804631b2f755dbf78cc8f3dc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>_keys</b> : unique_t { <b>DEFINE_KEY</b>, 
<b>num_symbols</b>
 }</td></tr>
<tr class="separator:a0292c5e8804631b2f755dbf78cc8f3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a363b7e068f27ecdb582f4a022904e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33a363b7e068f27ecdb582f4a022904e"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TypeKind</b> { <b>DEFINE_TYPE</b>
 }</td></tr>
<tr class="separator:a33a363b7e068f27ecdb582f4a022904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64cdd76c7657cda0c865ef9e5992fd3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#ad64cdd76c7657cda0c865ef9e5992fd3">Backend</a> { <br />
&#160;&#160;<b>CPU</b>, 
<b>CUDA</b>, 
<b>HIP</b>, 
<b>SparseCPU</b>, 
<br />
&#160;&#160;<b>SparseCUDA</b>, 
<b>SparseHIP</b>, 
<b>MSNPU</b>, 
<b>XLA</b>, 
<br />
&#160;&#160;<b>Undefined</b>, 
<b>NumOptions</b>
<br />
 }<tr class="memdesc:ad64cdd76c7657cda0c865ef9e5992fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This legacy enum class defines the set of backends supported by old school, code generated Type-based ATen.  <a href="namespacec10.html#ad64cdd76c7657cda0c865ef9e5992fd3">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad64cdd76c7657cda0c865ef9e5992fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852e40db880b4c34cf496a7f5e5b997a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a852e40db880b4c34cf496a7f5e5b997a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DeviceType</b> : int16_t { <br />
&#160;&#160;<b>CPU</b> = 0, 
<b>CUDA</b> = 1, 
<b>MKLDNN</b> = 2, 
<b>OPENGL</b> = 3, 
<br />
&#160;&#160;<b>OPENCL</b> = 4, 
<b>IDEEP</b> = 5, 
<b>HIP</b> = 6, 
<b>FPGA</b> = 7, 
<br />
&#160;&#160;<b>MSNPU</b> = 8, 
<b>XLA</b> = 9, 
<b>COMPILE_TIME_MAX_DEVICE_TYPES</b> = 10, 
<b>ONLY_FOR_TEST</b> = 20901
<br />
 }</td></tr>
<tr class="separator:a852e40db880b4c34cf496a7f5e5b997a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf44e4b11c463616dd0e47a4124c7398"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf44e4b11c463616dd0e47a4124c7398"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Layout</b> : int8_t { <b>Strided</b>, 
<b>Sparse</b>
 }</td></tr>
<tr class="separator:acf44e4b11c463616dd0e47a4124c7398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad662c67162e41ef98ddd0acaead0dfc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad662c67162e41ef98ddd0acaead0dfc1"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ScalarType</b> : int8_t { <b>DEFINE_ENUM</b>, 
<b>Undefined</b>, 
<b>NumOptions</b>
 }</td></tr>
<tr class="separator:ad662c67162e41ef98ddd0acaead0dfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4a0251b4d07edf65a2d1d035c47a78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e4a0251b4d07edf65a2d1d035c47a78"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>RegistryPriority</b> { <b>REGISTRY_FALLBACK</b> = 1, 
<b>REGISTRY_DEFAULT</b> = 2, 
<b>REGISTRY_PREFERRED</b> = 3
 }</td></tr>
<tr class="separator:a5e4a0251b4d07edf65a2d1d035c47a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a909d5b01fd0154384e5f57e2f6aea7e2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a909d5b01fd0154384e5f57e2f6aea7e2"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classc10_1_1_alias_info.html">AliasInfo</a> &amp;aliasInfo)</td></tr>
<tr class="separator:a909d5b01fd0154384e5f57e2f6aea7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3447e44af59545a3ebfe0e96e7ecf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f3447e44af59545a3ebfe0e96e7ecf5"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, <a class="el" href="namespacec10.html#ad64cdd76c7657cda0c865ef9e5992fd3">Backend</a> b)</td></tr>
<tr class="separator:a5f3447e44af59545a3ebfe0e96e7ecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda844582c594912db327db71e4e2461"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adda844582c594912db327db71e4e2461"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structc10_1_1_argument.html">Argument</a> &amp;arg)</td></tr>
<tr class="separator:adda844582c594912db327db71e4e2461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be4e47e4eb3a0cf8987350b6747d273"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6be4e47e4eb3a0cf8987350b6747d273"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structc10_1_1_function_schema.html">FunctionSchema</a> &amp;schema)</td></tr>
<tr class="separator:a6be4e47e4eb3a0cf8987350b6747d273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2365cd09fe904186254881247cb614"><td class="memTemplParams" colspan="2"><a class="anchor" id="afa2365cd09fe904186254881247cb614"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:afa2365cd09fe904186254881247cb614"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fmap</b> (const <a class="el" href="struct_t.html">T</a> &amp;inputs, const F &amp;fn) -&gt; std::vector&lt; decltype(fn(*inputs.begin()))&gt;</td></tr>
<tr class="separator:afa2365cd09fe904186254881247cb614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343680db7acf7005afcaf9e42048cd2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a343680db7acf7005afcaf9e42048cd2d"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a343680db7acf7005afcaf9e42048cd2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fmap</b> (<a class="el" href="struct_t.html">T</a> &amp;inputs, const F &amp;fn) -&gt; std::vector&lt; decltype(fn(*inputs.begin()))&gt;</td></tr>
<tr class="separator:a343680db7acf7005afcaf9e42048cd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb84901cfce50393af26d2c252f7f67"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1bb84901cfce50393af26d2c252f7f67"></a>
template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:a1bb84901cfce50393af26d2c252f7f67"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fmap</b> (const <a class="el" href="struct_t.html">T</a> &amp;inputs)</td></tr>
<tr class="separator:a1bb84901cfce50393af26d2c252f7f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091ce72d2ef0e5d85f697d772c8e6119"><td class="memTemplParams" colspan="2"><a class="anchor" id="a091ce72d2ef0e5d85f697d772c8e6119"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a091ce72d2ef0e5d85f697d772c8e6119"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_t.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>filter</b> (<a class="el" href="classc10_1_1_array_ref.html">at::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; inputs, const F &amp;fn)</td></tr>
<tr class="separator:a091ce72d2ef0e5d85f697d772c8e6119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2e2de0ba02e90639a2a3886256fe9d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e2e2de0ba02e90639a2a3886256fe9d"></a>
template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a0e2e2de0ba02e90639a2a3886256fe9d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_t.html">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>filter</b> (const std::vector&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;inputs, const F &amp;fn)</td></tr>
<tr class="separator:a0e2e2de0ba02e90639a2a3886256fe9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1a7e671f908f006f603779f3198caa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf1a7e671f908f006f603779f3198caa"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>domain_prefix</b> ()</td></tr>
<tr class="separator:aaf1a7e671f908f006f603779f3198caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a46b1e9b0d13e969b3731a87ed67c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53a46b1e9b0d13e969b3731a87ed67c9"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structc10_1_1_i_value.html">IValue</a> &amp;v)</td></tr>
<tr class="separator:a53a46b1e9b0d13e969b3731a87ed67c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939a617eac2887c88dfb9667d9ed2475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a939a617eac2887c88dfb9667d9ed2475"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DEFINE_TO</b> (<a class="el" href="classc10_1_1intrusive__ptr.html">c10::intrusive_ptr</a>&lt; <a class="el" href="classcaffe2_1_1_blob.html">caffe2::Blob</a> &gt;, toBlob)</td></tr>
<tr class="separator:a939a617eac2887c88dfb9667d9ed2475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a9163a12dfc0eaa02663c19dbf878e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65a9163a12dfc0eaa02663c19dbf878e"></a>
template&lt;typename Elem &gt; </td></tr>
<tr class="memitem:a65a9163a12dfc0eaa02663c19dbf878e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Elem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generic_to</b> (const <a class="el" href="structc10_1_1_i_value.html">IValue</a> *<a class="el" href="structc10_1_1ivalue.html">ivalue</a>, <a class="el" href="structc10_1_1__fake__type.html">_fake_type</a>&lt; std::vector&lt; Elem &gt;&gt;)</td></tr>
<tr class="separator:a65a9163a12dfc0eaa02663c19dbf878e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846d32e7b5488cb2f52499ebf3606bc0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a846d32e7b5488cb2f52499ebf3606bc0"></a>
template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a846d32e7b5488cb2f52499ebf3606bc0"><td class="memTemplItemLeft" align="right" valign="top">std::unordered_map&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generic_to</b> (const <a class="el" href="structc10_1_1_i_value.html">IValue</a> *<a class="el" href="structc10_1_1ivalue.html">ivalue</a>, <a class="el" href="structc10_1_1__fake__type.html">_fake_type</a>&lt; std::unordered_map&lt; K, V &gt;&gt;)</td></tr>
<tr class="separator:a846d32e7b5488cb2f52499ebf3606bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d18525df8828436a822ff19377d2bc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d18525df8828436a822ff19377d2bc3"></a>
CAFFE2_API const char *&#160;</td><td class="memItemRight" valign="bottom"><b>typeKindToString</b> (TypeKind kind)</td></tr>
<tr class="separator:a3d18525df8828436a822ff19377d2bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1d5a3fe235dd1eeda7479ba31685f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b1d5a3fe235dd1eeda7479ba31685f7"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structc10_1_1_type.html">Type</a> &amp;lhs, const <a class="el" href="structc10_1_1_type.html">Type</a> &amp;rhs)</td></tr>
<tr class="separator:a7b1d5a3fe235dd1eeda7479ba31685f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab98151213cd9f1604431f227e86487"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afab98151213cd9f1604431f227e86487"></a>
CAFFE2_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structc10_1_1_type.html">Type</a> &amp;t)</td></tr>
<tr class="separator:afab98151213cd9f1604431f227e86487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb1c1fdfa83ed40728d581beea0ba98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bb1c1fdfa83ed40728d581beea0ba98"></a>
TypePtr&#160;</td><td class="memItemRight" valign="bottom"><b>unshapedType</b> (const TypePtr &amp;type)</td></tr>
<tr class="separator:a5bb1c1fdfa83ed40728d581beea0ba98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd5c91389b4d48c13c1918f26a27f7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd5c91389b4d48c13c1918f26a27f7d"></a>
CAFFE2_API <a class="el" href="classc10_1_1optional.html">c10::optional</a>&lt; TypePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>unifyTypes</b> (const TypePtr &amp;t1, const TypePtr &amp;t2)</td></tr>
<tr class="separator:afcd5c91389b4d48c13c1918f26a27f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f2dc3f9161a8d17e67d54295ad63b3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46f2dc3f9161a8d17e67d54295ad63b3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a46f2dc3f9161a8d17e67d54295ad63b3"><td class="memTemplItemLeft" align="right" valign="top">TypePtr&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getTypePtr</b> ()</td></tr>
<tr class="separator:a46f2dc3f9161a8d17e67d54295ad63b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af26dfc7253c528d4b9314b15c68655"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9af26dfc7253c528d4b9314b15c68655"></a>
CAFFE2_API TypePtr&#160;</td><td class="memItemRight" valign="bottom"><b>incompleteInferTypeFrom</b> (const <a class="el" href="structc10_1_1_i_value.html">IValue</a> &amp;value)</td></tr>
<tr class="separator:a9af26dfc7253c528d4b9314b15c68655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbc1845b2ef21d4ccab31f866952598"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dbc1845b2ef21d4ccab31f866952598"></a>
CAFFE2_API TypePtr&#160;</td><td class="memItemRight" valign="bottom"><b>attemptToRecoverType</b> (const <a class="el" href="structc10_1_1_i_value.html">IValue</a> &amp;input_ivalue)</td></tr>
<tr class="separator:a7dbc1845b2ef21d4ccab31f866952598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5124c9e683e4edc4628d1e364bdc3e75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5124c9e683e4edc4628d1e364bdc3e75"></a>
CAFFE2_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSubvalueOf</b> (const <a class="el" href="structc10_1_1_i_value.html">IValue</a> &amp;input_ivalue, TypePtr type)</td></tr>
<tr class="separator:a5124c9e683e4edc4628d1e364bdc3e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18a8bbd737ef8e5baa1fffdc0162c47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab18a8bbd737ef8e5baa1fffdc0162c47"></a>
CAFFE2_API <a class="el" href="structc10_1_1_match_type_return.html">MatchTypeReturn</a>&#160;</td><td class="memItemRight" valign="bottom"><b>matchTypeVariables</b> (TypePtr formal, TypePtr actual, TypeEnv &amp;type_env)</td></tr>
<tr class="separator:ab18a8bbd737ef8e5baa1fffdc0162c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab01da83660e31dea8c2067305f2d5fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab01da83660e31dea8c2067305f2d5fb"></a>
CAFFE2_API TypePtr&#160;</td><td class="memItemRight" valign="bottom"><b>evalTypeVariables</b> (TypePtr type, TypeEnv &amp;type_env)</td></tr>
<tr class="separator:aab01da83660e31dea8c2067305f2d5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbaed3e37b01fa76849711a741986d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dbaed3e37b01fa76849711a741986d1"></a>
<a class="el" href="classc10_1_1optional.html">c10::optional</a>&lt; TypePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>tryEitherIsTheSuperType</b> (const TypePtr &amp;t1, const TypePtr &amp;t2)</td></tr>
<tr class="separator:a0dbaed3e37b01fa76849711a741986d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e34acb13752ed1ed2850edb8fce45f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70e34acb13752ed1ed2850edb8fce45f"></a>
CAFFE2_API TypePtr&#160;</td><td class="memItemRight" valign="bottom"><b>evalTypeVariables</b> (TypePtr type, std::unordered_map&lt; std::string, TypePtr &gt; &amp;type_env)</td></tr>
<tr class="separator:a70e34acb13752ed1ed2850edb8fce45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a51228c0961431eb78ca9d304b733b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44a51228c0961431eb78ca9d304b733b"></a>
<a class="el" href="classat_1_1_tensor.html">at::Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scalar_to_tensor</b> (<a class="el" href="classc10_1_1_scalar.html">Scalar</a> s)</td></tr>
<tr class="separator:a44a51228c0961431eb78ca9d304b733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abacacd5a4e4ef6ef00643e7fb4102e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a2abacacd5a4e4ef6ef00643e7fb4102e">SetAllocator</a> (DeviceType t, <a class="el" href="structc10_1_1_allocator.html">Allocator</a> *alloc)</td></tr>
<tr class="memdesc:a2abacacd5a4e4ef6ef00643e7fb4102e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the allocator for DeviceType <code>t</code>.  <a href="#a2abacacd5a4e4ef6ef00643e7fb4102e">More...</a><br /></td></tr>
<tr class="separator:a2abacacd5a4e4ef6ef00643e7fb4102e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a132c64dcc0d979422562168b46dbf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8a132c64dcc0d979422562168b46dbf"></a>
<a class="el" href="structc10_1_1_allocator.html">at::Allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetAllocator</b> (const at::DeviceType &amp;t)</td></tr>
<tr class="separator:ad8a132c64dcc0d979422562168b46dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db0647fd843dad645488e1476e4db23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4db0647fd843dad645488e1476e4db23"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classc10_1_1_data_ptr.html">DataPtr</a> &amp;dp, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a4db0647fd843dad645488e1476e4db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d0392c30e8c763cbee6b6f0da45134"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10d0392c30e8c763cbee6b6f0da45134"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (std::nullptr_t, const <a class="el" href="classc10_1_1_data_ptr.html">DataPtr</a> &amp;dp) noexcept</td></tr>
<tr class="separator:a10d0392c30e8c763cbee6b6f0da45134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de227ca7d172a0b481dcefad0bf4e2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3de227ca7d172a0b481dcefad0bf4e2e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classc10_1_1_data_ptr.html">DataPtr</a> &amp;dp, std::nullptr_t) noexcept</td></tr>
<tr class="separator:a3de227ca7d172a0b481dcefad0bf4e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00074b31bb8a1ada93cb33780339024c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00074b31bb8a1ada93cb33780339024c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (std::nullptr_t, const <a class="el" href="classc10_1_1_data_ptr.html">DataPtr</a> &amp;dp) noexcept</td></tr>
<tr class="separator:a00074b31bb8a1ada93cb33780339024c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8838a246463374eeb044244dc6bba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e8838a246463374eeb044244dc6bba1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyBytes</b> (size_t nbytes, const void *src, <a class="el" href="structc10_1_1_device.html">Device</a> src_device, void *dst, <a class="el" href="structc10_1_1_device.html">Device</a> dst_device, bool async)</td></tr>
<tr class="separator:a7e8838a246463374eeb044244dc6bba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e93e86856f454660995809dc7083c54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e93e86856f454660995809dc7083c54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>memset_junk</b> (void *data, size_t num)</td></tr>
<tr class="separator:a4e93e86856f454660995809dc7083c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599322b87a6a1e785eb7626824f27056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a599322b87a6a1e785eb7626824f27056"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>alloc_cpu</b> (size_t nbytes)</td></tr>
<tr class="separator:a599322b87a6a1e785eb7626824f27056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad166dcc5bb7349b51c2367d73108b3cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad166dcc5bb7349b51c2367d73108b3cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_cpu</b> (void *data)</td></tr>
<tr class="separator:ad166dcc5bb7349b51c2367d73108b3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31a90ee3aadd4e5badb90afc58d61f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae31a90ee3aadd4e5badb90afc58d61f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>NoDelete</b> (void *)</td></tr>
<tr class="separator:ae31a90ee3aadd4e5badb90afc58d61f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ff77a24aadde53638a85f11cbaa65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a991ff77a24aadde53638a85f11cbaa65"></a>
<a class="el" href="structc10_1_1_allocator.html">at::Allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetCPUAllocator</b> ()</td></tr>
<tr class="separator:a991ff77a24aadde53638a85f11cbaa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a28bdec3134a0158cfa36dfda7c13f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74a28bdec3134a0158cfa36dfda7c13f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetCPUAllocator</b> (<a class="el" href="structc10_1_1_allocator.html">at::Allocator</a> *alloc)</td></tr>
<tr class="separator:a74a28bdec3134a0158cfa36dfda7c13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fbef9d5e9f312da08fe950da616fccb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fbef9d5e9f312da08fe950da616fccb"></a>
<a class="el" href="structc10_1_1_allocator.html">at::Allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetDefaultCPUAllocator</b> ()</td></tr>
<tr class="separator:a7fbef9d5e9f312da08fe950da616fccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab542cc361a1be3c7db695d8af84ba4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab542cc361a1be3c7db695d8af84ba4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_ALLOCATOR</b> (DeviceType::CPU,&amp;g_cpu_alloc)</td></tr>
<tr class="separator:a0ab542cc361a1be3c7db695d8af84ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e62a851cea4b701bf1c410e19e7207a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e62a851cea4b701bf1c410e19e7207a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_default_dtype</b> (<a class="el" href="classcaffe2_1_1_type_meta.html">caffe2::TypeMeta</a> <a class="el" href="namespacec10.html#a29c51d9aeae386461db374b6d76dec65">dtype</a>)</td></tr>
<tr class="separator:a2e62a851cea4b701bf1c410e19e7207a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769a39c1b8faa327cedb0a62a5238093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a769a39c1b8faa327cedb0a62a5238093"></a>
const <a class="el" href="classcaffe2_1_1_type_meta.html">caffe2::TypeMeta</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_default_dtype</b> ()</td></tr>
<tr class="separator:a769a39c1b8faa327cedb0a62a5238093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866e1405e7da81b8b23016d6b2f26013"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a866e1405e7da81b8b23016d6b2f26013"></a>
const <a class="el" href="structc10_1_1_default_tensor_options.html">DefaultTensorOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getDefaultTensorOptions</b> ()</td></tr>
<tr class="separator:a866e1405e7da81b8b23016d6b2f26013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7a4462234a3e451d6ee248e5add8e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d7a4462234a3e451d6ee248e5add8e3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;stream, const <a class="el" href="structc10_1_1_device.html">Device</a> &amp;<a class="el" href="namespacec10.html#a86a64d5723fb1713c8a3d8e546a561ea">device</a>)</td></tr>
<tr class="separator:a0d7a4462234a3e451d6ee248e5add8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8248dcb4f5556fb8600381bef378b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c8248dcb4f5556fb8600381bef378b1"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceTypeName</b> (DeviceType d, bool lower_case)</td></tr>
<tr class="separator:a5c8248dcb4f5556fb8600381bef378b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa752bbbb3749441a2aa752456ed6823a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa752bbbb3749441a2aa752456ed6823a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isValidDeviceType</b> (DeviceType d)</td></tr>
<tr class="separator:aa752bbbb3749441a2aa752456ed6823a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87e1ce67467d40849907e724f88dfe7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae87e1ce67467d40849907e724f88dfe7"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;stream, DeviceType type)</td></tr>
<tr class="separator:ae87e1ce67467d40849907e724f88dfe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33842d66d9a98cfa63a58a3c2bb71cd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33842d66d9a98cfa63a58a3c2bb71cd9"></a>
Layout&#160;</td><td class="memItemRight" valign="bottom"><b>layout_from_backend</b> (<a class="el" href="namespacec10.html#ad64cdd76c7657cda0c865ef9e5992fd3">Backend</a> backend)</td></tr>
<tr class="separator:a33842d66d9a98cfa63a58a3c2bb71cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc78034c4367719e15b648019286229a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc78034c4367719e15b648019286229a"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;stream, at::Layout <a class="el" href="namespacec10.html#a71edc8f1f2dfaf2eed7d27d9536ae277">layout</a>)</td></tr>
<tr class="separator:afc78034c4367719e15b648019286229a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d1310027aa6f460d58723fadb9f241"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5d1310027aa6f460d58723fadb9f241"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;stream, at::ScalarType scalar_type)</td></tr>
<tr class="separator:ad5d1310027aa6f460d58723fadb9f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ec3c492a6682ccb6221c1d009befdc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80ec3c492a6682ccb6221c1d009befdc"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;stream, const <a class="el" href="classc10_1_1_stream.html">Stream</a> &amp;s)</td></tr>
<tr class="separator:a80ec3c492a6682ccb6221c1d009befdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d919a7f048eb189ddf84cbf9e83c2a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d919a7f048eb189ddf84cbf9e83c2a2"></a>
std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a7d919a7f048eb189ddf84cbf9e83c2a2">ToVectorint64_t</a> (<a class="el" href="classc10_1_1_array_ref.html">ArrayRef</a>&lt; int &gt; src)</td></tr>
<tr class="memdesc:a7d919a7f048eb189ddf84cbf9e83c2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> utility function to convert vector&lt;int&gt; to vector&lt;int64_t&gt;. <br /></td></tr>
<tr class="separator:a7d919a7f048eb189ddf84cbf9e83c2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77eb9df108ba3aaac4963465630706b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77eb9df108ba3aaac4963465630706b6"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a77eb9df108ba3aaac4963465630706b6">size_from_dim_</a> (int k, <a class="el" href="classc10_1_1_array_ref.html">IntArrayRef</a> dims)</td></tr>
<tr class="memdesc:a77eb9df108ba3aaac4963465630706b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of all dimensions starting from k. <br /></td></tr>
<tr class="separator:a77eb9df108ba3aaac4963465630706b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7345bc84b0e7c17f293689fbed9a7291"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7345bc84b0e7c17f293689fbed9a7291"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_to_dim_</b> (int k, <a class="el" href="classc10_1_1_array_ref.html">IntArrayRef</a> dims)</td></tr>
<tr class="separator:a7345bc84b0e7c17f293689fbed9a7291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499ecb7248ca2908796b8db9b564fda7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a499ecb7248ca2908796b8db9b564fda7"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>size_between_dim_</b> (int k, int l, <a class="el" href="classc10_1_1_array_ref.html">IntArrayRef</a> dims)</td></tr>
<tr class="separator:a499ecb7248ca2908796b8db9b564fda7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fba9fb22fd2f9e5fa788e9490fe2cf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fba9fb22fd2f9e5fa788e9490fe2cf5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis_index_</b> (int axis_index, int ndims)</td></tr>
<tr class="separator:a2fba9fb22fd2f9e5fa788e9490fe2cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134edc526db8a81b0cdf983cd8ac1019"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a134edc526db8a81b0cdf983cd8ac1019"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;stream, const <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> &amp;options)</td></tr>
<tr class="separator:a134edc526db8a81b0cdf983cd8ac1019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38754f58b3aa8b69daecd7a0c3d34d5a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a38754f58b3aa8b69daecd7a0c3d34d5a">TensorOptions</a> (<a class="el" href="struct_t.html">T</a> &amp;&amp;<a class="el" href="namespacec10.html#a86a64d5723fb1713c8a3d8e546a561ea">device</a>)</td></tr>
<tr class="memdesc:a38754f58b3aa8b69daecd7a0c3d34d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> class to encapsulate construction axes of an <a class="el" href="struct_tensor.html">Tensor</a>.  <a href="#a38754f58b3aa8b69daecd7a0c3d34d5a">More...</a><br /></td></tr>
<tr class="separator:a38754f58b3aa8b69daecd7a0c3d34d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe8b0dfcb681d24e82bd239d3322b6d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adfe8b0dfcb681d24e82bd239d3322b6d"></a>
template&lt;typename... Args, * typename = std::enable_if_t&lt;std::is_constructible&lt;Device, Args&amp;&amp;...&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:adfe8b0dfcb681d24e82bd239d3322b6d"><td class="memTemplItemLeft" align="right" valign="top">***&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TensorOptions</b> (Args &amp;&amp;...args)*</td></tr>
<tr class="separator:adfe8b0dfcb681d24e82bd239d3322b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c51d9aeae386461db374b6d76dec65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a29c51d9aeae386461db374b6d76dec65">dtype</a> (<a class="el" href="classcaffe2_1_1_type_meta.html">caffe2::TypeMeta</a> dtype)</td></tr>
<tr class="memdesc:a29c51d9aeae386461db374b6d76dec65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>dtype</code> set to the given one.  <a href="#a29c51d9aeae386461db374b6d76dec65">More...</a><br /></td></tr>
<tr class="separator:a29c51d9aeae386461db374b6d76dec65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37d7057e8426d410eee32d6e16e0020"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af37d7057e8426d410eee32d6e16e0020"></a>
<a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dtype</b> (ScalarType dtype)</td></tr>
<tr class="separator:af37d7057e8426d410eee32d6e16e0020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71edc8f1f2dfaf2eed7d27d9536ae277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a71edc8f1f2dfaf2eed7d27d9536ae277">layout</a> (Layout layout)</td></tr>
<tr class="memdesc:a71edc8f1f2dfaf2eed7d27d9536ae277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>layout</code> set to the given one.  <a href="#a71edc8f1f2dfaf2eed7d27d9536ae277">More...</a><br /></td></tr>
<tr class="separator:a71edc8f1f2dfaf2eed7d27d9536ae277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a64d5723fb1713c8a3d8e546a561ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a86a64d5723fb1713c8a3d8e546a561ea">device</a> (<a class="el" href="structc10_1_1_device.html">Device</a> device)</td></tr>
<tr class="memdesc:a86a64d5723fb1713c8a3d8e546a561ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>device</code> set to the given one.  <a href="#a86a64d5723fb1713c8a3d8e546a561ea">More...</a><br /></td></tr>
<tr class="separator:a86a64d5723fb1713c8a3d8e546a561ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe14c970ecafbf1c875242c39128c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a0fe14c970ecafbf1c875242c39128c5b">device_index</a> (int16_t device_index)</td></tr>
<tr class="memdesc:a0fe14c970ecafbf1c875242c39128c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>device</code> set to CUDA and the <code>device_index</code> set to the given one.  <a href="#a0fe14c970ecafbf1c875242c39128c5b">More...</a><br /></td></tr>
<tr class="separator:a0fe14c970ecafbf1c875242c39128c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2f14627a60d06b6d14c2339531798b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#afc2f14627a60d06b6d14c2339531798b">requires_grad</a> (bool requires_grad=true)</td></tr>
<tr class="memdesc:afc2f14627a60d06b6d14c2339531798b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>requires_grad</code> set to the given one.  <a href="#afc2f14627a60d06b6d14c2339531798b">More...</a><br /></td></tr>
<tr class="separator:afc2f14627a60d06b6d14c2339531798b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85105e10b6cc750128918e0d1a9f202a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85105e10b6cc750128918e0d1a9f202a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85105e10b6cc750128918e0d1a9f202a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dtype</b> ()</td></tr>
<tr class="separator:a85105e10b6cc750128918e0d1a9f202a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa366f09b3264bcad170d5dfcd3a04235"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa366f09b3264bcad170d5dfcd3a04235"></a>
<a class="el" href="classc10_1_1_tensor_type_id.html">TensorTypeId</a>&#160;</td><td class="memItemRight" valign="bottom"><b>computeTensorTypeId</b> (<a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> options)</td></tr>
<tr class="separator:aa366f09b3264bcad170d5dfcd3a04235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98c46ecb875554529a8a5e139d260a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae98c46ecb875554529a8a5e139d260a9"></a>
DeviceType&#160;</td><td class="memItemRight" valign="bottom"><b>computeDeviceType</b> (<a class="el" href="classc10_1_1_tensor_type_id.html">TensorTypeId</a> tid)</td></tr>
<tr class="separator:ae98c46ecb875554529a8a5e139d260a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab58b0c936332f6f6c33c6ab420aed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaab58b0c936332f6f6c33c6ab420aed6"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;str, <a class="el" href="classc10_1_1_tensor_type_id.html">c10::TensorTypeId</a> rhs)</td></tr>
<tr class="separator:aaab58b0c936332f6f6c33c6ab420aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112aa8c58dcc5f2cabea29bf939d3062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a112aa8c58dcc5f2cabea29bf939d3062"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>toString</b> (<a class="el" href="classc10_1_1_tensor_type_id.html">TensorTypeId</a> id)</td></tr>
<tr class="separator:a112aa8c58dcc5f2cabea29bf939d3062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb0fc523a24fe21671cc7ef23a49817"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cb0fc523a24fe21671cc7ef23a49817"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (UndefinedTensorId)</td></tr>
<tr class="separator:a1cb0fc523a24fe21671cc7ef23a49817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005b857136d3d3e4e42978477005940a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a005b857136d3d3e4e42978477005940a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (CPUTensorId)</td></tr>
<tr class="separator:a005b857136d3d3e4e42978477005940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77045e2c5b9eab42fce0f9c905795436"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77045e2c5b9eab42fce0f9c905795436"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (CUDATensorId)</td></tr>
<tr class="separator:a77045e2c5b9eab42fce0f9c905795436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487722538ce466b6d71b502140ed1f3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a487722538ce466b6d71b502140ed1f3a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (SparseCPUTensorId)</td></tr>
<tr class="separator:a487722538ce466b6d71b502140ed1f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70d50662bacad60affa02e8a0b2a86b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af70d50662bacad60affa02e8a0b2a86b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (SparseCUDATensorId)</td></tr>
<tr class="separator:af70d50662bacad60affa02e8a0b2a86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6941ce9eef13be118fe5f21d235ba32f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6941ce9eef13be118fe5f21d235ba32f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (MKLDNNTensorId)</td></tr>
<tr class="separator:a6941ce9eef13be118fe5f21d235ba32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe3fc2b0a8b3cb0f41a042037ccf864"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fe3fc2b0a8b3cb0f41a042037ccf864"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (OpenGLTensorId)</td></tr>
<tr class="separator:a2fe3fc2b0a8b3cb0f41a042037ccf864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20f9a4de2c1cf0dfe9ed9c529510b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c20f9a4de2c1cf0dfe9ed9c529510b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (OpenCLTensorId)</td></tr>
<tr class="separator:a6c20f9a4de2c1cf0dfe9ed9c529510b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d3a3abae13c9b73f1ba4ce9f6f8d0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59d3a3abae13c9b73f1ba4ce9f6f8d0a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (IDEEPTensorId)</td></tr>
<tr class="separator:a59d3a3abae13c9b73f1ba4ce9f6f8d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89c5e363ab3fde9f9d8a9da744518e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac89c5e363ab3fde9f9d8a9da744518e7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (HIPTensorId)</td></tr>
<tr class="separator:ac89c5e363ab3fde9f9d8a9da744518e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985ce9d803d84207d3fb0c88e1350574"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a985ce9d803d84207d3fb0c88e1350574"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (SparseHIPTensorId)</td></tr>
<tr class="separator:a985ce9d803d84207d3fb0c88e1350574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb33ae14cefd0e4a3b6d911028dfdbcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb33ae14cefd0e4a3b6d911028dfdbcf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (MSNPUTensorId)</td></tr>
<tr class="separator:abb33ae14cefd0e4a3b6d911028dfdbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b0c0f0bf8abc4ffcf64a5f6ca6e606"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60b0c0f0bf8abc4ffcf64a5f6ca6e606"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_TENSOR_TYPE</b> (XLATensorId)</td></tr>
<tr class="separator:a60b0c0f0bf8abc4ffcf64a5f6ca6e606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c75294fb2ceccb654fe38c13723d24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76c75294fb2ceccb654fe38c13723d24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (UndefinedTensorId)</td></tr>
<tr class="separator:a76c75294fb2ceccb654fe38c13723d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b88e683e00859b1c4413e60b26a266"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7b88e683e00859b1c4413e60b26a266"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (CPUTensorId)</td></tr>
<tr class="separator:af7b88e683e00859b1c4413e60b26a266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b090a01cfb37218b0c97dfaa8b46db3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b090a01cfb37218b0c97dfaa8b46db3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (CUDATensorId)</td></tr>
<tr class="separator:a1b090a01cfb37218b0c97dfaa8b46db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a5f59e088d5c17b3c1b7fd77538e10"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1a5f59e088d5c17b3c1b7fd77538e10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (SparseCPUTensorId)</td></tr>
<tr class="separator:ac1a5f59e088d5c17b3c1b7fd77538e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d90af5c2755d42bf23bc2fb0d5755cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d90af5c2755d42bf23bc2fb0d5755cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (SparseCUDATensorId)</td></tr>
<tr class="separator:a3d90af5c2755d42bf23bc2fb0d5755cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3219506c7f61cd9fb3254e979a285832"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3219506c7f61cd9fb3254e979a285832"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (MKLDNNTensorId)</td></tr>
<tr class="separator:a3219506c7f61cd9fb3254e979a285832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95798c585a0ec77f2a29f02b3804744d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95798c585a0ec77f2a29f02b3804744d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (OpenGLTensorId)</td></tr>
<tr class="separator:a95798c585a0ec77f2a29f02b3804744d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7975054915ec729a81a23596654e9e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7975054915ec729a81a23596654e9e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (OpenCLTensorId)</td></tr>
<tr class="separator:ab7975054915ec729a81a23596654e9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dc16491c20328bfd510ca49c83d51d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16dc16491c20328bfd510ca49c83d51d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (IDEEPTensorId)</td></tr>
<tr class="separator:a16dc16491c20328bfd510ca49c83d51d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270ba3e057481f1c10990642332128fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a270ba3e057481f1c10990642332128fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (HIPTensorId)</td></tr>
<tr class="separator:a270ba3e057481f1c10990642332128fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4882d91079f492def8eb4fa3f0bb14cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4882d91079f492def8eb4fa3f0bb14cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (SparseHIPTensorId)</td></tr>
<tr class="separator:a4882d91079f492def8eb4fa3f0bb14cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609e3b577ab1d17aafbeecd216771ff3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a609e3b577ab1d17aafbeecd216771ff3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (MSNPUTensorId)</td></tr>
<tr class="separator:a609e3b577ab1d17aafbeecd216771ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01e1e375426e3e0b43eb77aa4ed98d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa01e1e375426e3e0b43eb77aa4ed98d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_TENSOR_TYPE</b> (XLATensorId)</td></tr>
<tr class="separator:aa01e1e375426e3e0b43eb77aa4ed98d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae878fbc832ce78fe4e47850c5a81512f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae878fbc832ce78fe4e47850c5a81512f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setNumThreads</b> (size_t v)</td></tr>
<tr class="separator:ae878fbc832ce78fe4e47850c5a81512f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd20fa98b3c711d8b4c321663a564040"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd20fa98b3c711d8b4c321663a564040"></a>
<a class="el" href="classc10_1_1_task_thread_pool_base.html">TaskThreadPoolBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>global_work_queue</b> ()</td></tr>
<tr class="separator:afd20fa98b3c711d8b4c321663a564040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051bb157c2ca54a2c34ca5750f8f87dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a051bb157c2ca54a2c34ca5750f8f87dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_SHARED_REGISTRY</b> (ThreadPoolRegistry, <a class="el" href="classc10_1_1_task_thread_pool_base.html">TaskThreadPoolBase</a>, int, int, bool)</td></tr>
<tr class="separator:a051bb157c2ca54a2c34ca5750f8f87dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52aa4c3808634e811105a246992b24c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52aa4c3808634e811105a246992b24c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_REGISTER_CREATOR</b> (ThreadPoolRegistry, C10, createC10ThreadPool)</td></tr>
<tr class="separator:a52aa4c3808634e811105a246992b24c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6f0e7dee72988eadad0fb558e4d350"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6f0e7dee72988eadad0fb558e4d350"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_SHARED_REGISTRY</b> (ThreadPoolRegistry, <a class="el" href="classc10_1_1_task_thread_pool_base.html">TaskThreadPoolBase</a>, int, int, bool)</td></tr>
<tr class="separator:a5b6f0e7dee72988eadad0fb558e4d350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4033b4c1ecbf6edced966f5096ae5e7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4033b4c1ecbf6edced966f5096ae5e7d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4033b4c1ecbf6edced966f5096ae5e7d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, <a class="el" href="classc10_1_1_array_ref.html">ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; list)</td></tr>
<tr class="separator:a4033b4c1ecbf6edced966f5096ae5e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42fddaa2d995cebb32dcd85a5d27981"><td class="memTemplParams" colspan="2"><a class="anchor" id="af42fddaa2d995cebb32dcd85a5d27981"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af42fddaa2d995cebb32dcd85a5d27981"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classc10_1_1_array_ref.html">c10::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; a1, <a class="el" href="classc10_1_1_array_ref.html">c10::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; a2)</td></tr>
<tr class="separator:af42fddaa2d995cebb32dcd85a5d27981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051a438c3cfc0d85e0aff15a05e9c5cd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a051a438c3cfc0d85e0aff15a05e9c5cd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a051a438c3cfc0d85e0aff15a05e9c5cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classc10_1_1_array_ref.html">c10::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; a1, <a class="el" href="classc10_1_1_array_ref.html">c10::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; a2)</td></tr>
<tr class="separator:a051a438c3cfc0d85e0aff15a05e9c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5d4002b680f05b8245d609cc350b44"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f5d4002b680f05b8245d609cc350b44"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f5d4002b680f05b8245d609cc350b44"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (std::vector&lt; <a class="el" href="struct_t.html">T</a> &gt; a1, <a class="el" href="classc10_1_1_array_ref.html">c10::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; a2)</td></tr>
<tr class="separator:a1f5d4002b680f05b8245d609cc350b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d53fd3de6aec077c004a442bbae4dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5d53fd3de6aec077c004a442bbae4dc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5d53fd3de6aec077c004a442bbae4dc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (std::vector&lt; <a class="el" href="struct_t.html">T</a> &gt; a1, <a class="el" href="classc10_1_1_array_ref.html">c10::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; a2)</td></tr>
<tr class="separator:aa5d53fd3de6aec077c004a442bbae4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4934db45076469097310a99493849bab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4934db45076469097310a99493849bab"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4934db45076469097310a99493849bab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="classc10_1_1_array_ref.html">c10::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; a1, std::vector&lt; <a class="el" href="struct_t.html">T</a> &gt; a2)</td></tr>
<tr class="separator:a4934db45076469097310a99493849bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192c1a90ff2927b246f98da1dc105c3a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a192c1a90ff2927b246f98da1dc105c3a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a192c1a90ff2927b246f98da1dc105c3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="classc10_1_1_array_ref.html">c10::ArrayRef</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; a1, std::vector&lt; <a class="el" href="struct_t.html">T</a> &gt; a2)</td></tr>
<tr class="separator:a192c1a90ff2927b246f98da1dc105c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e0921eb1c042101099587ae0162bd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e0921eb1c042101099587ae0162bd3"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>get_backtrace</b> (size_t frames_to_skip, size_t maximum_number_of_frames, bool skip_python_frames)</td></tr>
<tr class="separator:ab9e0921eb1c042101099587ae0162bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9067f1293762de391375827a517efb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9067f1293762de391375827a517efb5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>GetExceptionString</b> (const std::exception &amp;e)</td></tr>
<tr class="separator:ad9067f1293762de391375827a517efb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b39560b2f347e328fafd7271b090817"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b39560b2f347e328fafd7271b090817"></a>
C10_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a1b39560b2f347e328fafd7271b090817">SetUsageMessage</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a1b39560b2f347e328fafd7271b090817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the usage message when a commandline tool is called with "--help". <br /></td></tr>
<tr class="separator:a1b39560b2f347e328fafd7271b090817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb5884b3a63c798b4c21fd4d583f4a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fb5884b3a63c798b4c21fd4d583f4a6"></a>
C10_API const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a2fb5884b3a63c798b4c21fd4d583f4a6">UsageMessage</a> ()</td></tr>
<tr class="memdesc:a2fb5884b3a63c798b4c21fd4d583f4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the usage message for the commandline tool set by SetUsageMessage. <br /></td></tr>
<tr class="separator:a2fb5884b3a63c798b4c21fd4d583f4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e4d7151bcdbf4f0c47179551ff65f8"><td class="memItemLeft" align="right" valign="top">C10_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a01e4d7151bcdbf4f0c47179551ff65f8">ParseCommandLineFlags</a> (int *pargc, char ***pargv)</td></tr>
<tr class="memdesc:a01e4d7151bcdbf4f0c47179551ff65f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the commandline flags.  <a href="#a01e4d7151bcdbf4f0c47179551ff65f8">More...</a><br /></td></tr>
<tr class="separator:a01e4d7151bcdbf4f0c47179551ff65f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6eb083219d93915e77026b9d4f79693"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6eb083219d93915e77026b9d4f79693"></a>
C10_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#aa6eb083219d93915e77026b9d4f79693">CommandLineFlagsHasBeenParsed</a> ()</td></tr>
<tr class="memdesc:aa6eb083219d93915e77026b9d4f79693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the commandline flags has already been passed. <br /></td></tr>
<tr class="separator:aa6eb083219d93915e77026b9d4f79693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3aca2669be419a9fda33518ca28bb29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3aca2669be419a9fda33518ca28bb29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DECLARE_REGISTRY</b> (C10FlagsRegistry, <a class="el" href="classc10_1_1_c10_flag_parser.html">C10FlagParser</a>, const std::string &amp;)</td></tr>
<tr class="separator:aa3aca2669be419a9fda33518ca28bb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76082366142da4d8db90460f4203817f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76082366142da4d8db90460f4203817f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_DEFINE_REGISTRY</b> (C10FlagsRegistry, <a class="el" href="classc10_1_1_c10_flag_parser.html">C10FlagParser</a>, const string &amp;)</td></tr>
<tr class="separator:a76082366142da4d8db90460f4203817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38929bb1d18b44c53cdeea716d26e58c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38929bb1d18b44c53cdeea716d26e58c"></a>
C10_EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><b>SetUsageMessage</b> (const string &amp;str)</td></tr>
<tr class="separator:a38929bb1d18b44c53cdeea716d26e58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7896e1be1585a142a3924003fa473d45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7896e1be1585a142a3924003fa473d45"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a7896e1be1585a142a3924003fa473d45">operator+</a> (const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="memdesc:a7896e1be1585a142a3924003fa473d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic. <br /></td></tr>
<tr class="separator:a7896e1be1585a142a3924003fa473d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb269470f8a66484820525e8b8b3753a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb269470f8a66484820525e8b8b3753a"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:afb269470f8a66484820525e8b8b3753a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1724e80b3b2eaa599730f6bfe24903d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1724e80b3b2eaa599730f6bfe24903d7"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:a1724e80b3b2eaa599730f6bfe24903d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f6346dd46380af717e58a96892ad70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95f6346dd46380af717e58a96892ad70"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:a95f6346dd46380af717e58a96892ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d8299cf154e89c7eedff3b22f2dd26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20d8299cf154e89c7eedff3b22f2dd26"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;a)</td></tr>
<tr class="separator:a20d8299cf154e89c7eedff3b22f2dd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e3dec0bf2f60a57838cad295f4c267"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2e3dec0bf2f60a57838cad295f4c267"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (<a class="el" href="structc10_1_1_half.html">Half</a> &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:ae2e3dec0bf2f60a57838cad295f4c267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a471a888bfc00577787a4a3439786c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4a471a888bfc00577787a4a3439786c"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (<a class="el" href="structc10_1_1_half.html">Half</a> &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:ab4a471a888bfc00577787a4a3439786c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6f3b32027d61d2a58ab1aab66ffd81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb6f3b32027d61d2a58ab1aab66ffd81"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (<a class="el" href="structc10_1_1_half.html">Half</a> &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:abb6f3b32027d61d2a58ab1aab66ffd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb3d8cf8a7556b13ee46c7f29847b06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cb3d8cf8a7556b13ee46c7f29847b06"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (<a class="el" href="structc10_1_1_half.html">Half</a> &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:a6cb3d8cf8a7556b13ee46c7f29847b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6c03dad1a342954b76ce4470b7f325"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c6c03dad1a342954b76ce4470b7f325"></a>
C10_HOST_DEVICE float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a9c6c03dad1a342954b76ce4470b7f325">operator+</a> (<a class="el" href="structc10_1_1_half.html">Half</a> a, float b)</td></tr>
<tr class="memdesc:a9c6c03dad1a342954b76ce4470b7f325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic with floats. <br /></td></tr>
<tr class="separator:a9c6c03dad1a342954b76ce4470b7f325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b633f88312f93afb48fde0b60b8e958"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b633f88312f93afb48fde0b60b8e958"></a>
C10_HOST_DEVICE float&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, float b)</td></tr>
<tr class="separator:a2b633f88312f93afb48fde0b60b8e958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8d448f36bd758323feb59365a49d3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add8d448f36bd758323feb59365a49d3f"></a>
C10_HOST_DEVICE float&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, float b)</td></tr>
<tr class="separator:add8d448f36bd758323feb59365a49d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb92ef62c77bb689f0de11ab6a5d91c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2eb92ef62c77bb689f0de11ab6a5d91c"></a>
C10_HOST_DEVICE float&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, float b)</td></tr>
<tr class="separator:a2eb92ef62c77bb689f0de11ab6a5d91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9a4bb73e3870233411f69ffd26185f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb9a4bb73e3870233411f69ffd26185f"></a>
C10_HOST_DEVICE float&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (float a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:abb9a4bb73e3870233411f69ffd26185f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd626f095efa809df302160de69f7734"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd626f095efa809df302160de69f7734"></a>
C10_HOST_DEVICE float&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (float a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:afd626f095efa809df302160de69f7734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca86048efaf91fdcf77c0261515c7eac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca86048efaf91fdcf77c0261515c7eac"></a>
C10_HOST_DEVICE float&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (float a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:aca86048efaf91fdcf77c0261515c7eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b41da691947b4d0e667d6fd5e9fab20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b41da691947b4d0e667d6fd5e9fab20"></a>
C10_HOST_DEVICE float&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (float a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a6b41da691947b4d0e667d6fd5e9fab20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7662d8958a6f0209b64b79cf692326ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7662d8958a6f0209b64b79cf692326ce"></a>
C10_HOST_DEVICE float &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (float &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:a7662d8958a6f0209b64b79cf692326ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796845637bda938cb1e110975c8812af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a796845637bda938cb1e110975c8812af"></a>
C10_HOST_DEVICE float &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (float &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:a796845637bda938cb1e110975c8812af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d470eb8eca155bd415a0d061c58460"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8d470eb8eca155bd415a0d061c58460"></a>
C10_HOST_DEVICE float &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator*=</b> (float &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:ab8d470eb8eca155bd415a0d061c58460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd66a3b3ed8cfe0b9acd9a8381c0752"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dd66a3b3ed8cfe0b9acd9a8381c0752"></a>
C10_HOST_DEVICE float &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator/=</b> (float &amp;a, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;b)</td></tr>
<tr class="separator:a7dd66a3b3ed8cfe0b9acd9a8381c0752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cd931f178a72453c9a0243fea361d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1cd931f178a72453c9a0243fea361d0"></a>
C10_HOST_DEVICE double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#ac1cd931f178a72453c9a0243fea361d0">operator+</a> (<a class="el" href="structc10_1_1_half.html">Half</a> a, double b)</td></tr>
<tr class="memdesc:ac1cd931f178a72453c9a0243fea361d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic with doubles. <br /></td></tr>
<tr class="separator:ac1cd931f178a72453c9a0243fea361d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d9a31b54c34c86939872e85b3e594c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53d9a31b54c34c86939872e85b3e594c"></a>
C10_HOST_DEVICE double&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, double b)</td></tr>
<tr class="separator:a53d9a31b54c34c86939872e85b3e594c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed9f7bdb9e36219a074799545d0b0ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ed9f7bdb9e36219a074799545d0b0ff"></a>
C10_HOST_DEVICE double&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, double b)</td></tr>
<tr class="separator:a7ed9f7bdb9e36219a074799545d0b0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c520c9701914e7234f61e3a00f83d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5c520c9701914e7234f61e3a00f83d7"></a>
C10_HOST_DEVICE double&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, double b)</td></tr>
<tr class="separator:ad5c520c9701914e7234f61e3a00f83d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42779602986426e026da7bd99c3375e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af42779602986426e026da7bd99c3375e"></a>
C10_HOST_DEVICE double&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (double a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:af42779602986426e026da7bd99c3375e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab713ad55cae8acb4f3da9904b933f65b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab713ad55cae8acb4f3da9904b933f65b"></a>
C10_HOST_DEVICE double&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (double a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:ab713ad55cae8acb4f3da9904b933f65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f66d1a6c4f5abf1a70355c34868135"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03f66d1a6c4f5abf1a70355c34868135"></a>
C10_HOST_DEVICE double&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a03f66d1a6c4f5abf1a70355c34868135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd912d79eb9d3393bc06b55699eb94cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd912d79eb9d3393bc06b55699eb94cc"></a>
C10_HOST_DEVICE double&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (double a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:abd912d79eb9d3393bc06b55699eb94cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75a05f28923fbd36cbe594bd3189689"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab75a05f28923fbd36cbe594bd3189689"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#ab75a05f28923fbd36cbe594bd3189689">operator+</a> (<a class="el" href="structc10_1_1_half.html">Half</a> a, int b)</td></tr>
<tr class="memdesc:ab75a05f28923fbd36cbe594bd3189689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic with ints. <br /></td></tr>
<tr class="separator:ab75a05f28923fbd36cbe594bd3189689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e0bd51a8f7fbfd4672cde389144442"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57e0bd51a8f7fbfd4672cde389144442"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, int b)</td></tr>
<tr class="separator:a57e0bd51a8f7fbfd4672cde389144442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c84a9f18e9894d17973e456b64d92d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c84a9f18e9894d17973e456b64d92d1"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, int b)</td></tr>
<tr class="separator:a2c84a9f18e9894d17973e456b64d92d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80173cad6d476a633f3ac8911a566081"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80173cad6d476a633f3ac8911a566081"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, int b)</td></tr>
<tr class="separator:a80173cad6d476a633f3ac8911a566081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bb64bf8025334812bf89370bce6e81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2bb64bf8025334812bf89370bce6e81"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (int a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:ae2bb64bf8025334812bf89370bce6e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a33c5444af51388b22022336653b701"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a33c5444af51388b22022336653b701"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (int a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a5a33c5444af51388b22022336653b701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc85337cfb69125607c67506220d75b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc85337cfb69125607c67506220d75b"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (int a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a5bc85337cfb69125607c67506220d75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c8401fd7907815aaba2f54533a5007"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c8401fd7907815aaba2f54533a5007"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (int a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a47c8401fd7907815aaba2f54533a5007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a64bafd76dd87fefe203a73763b33e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a64bafd76dd87fefe203a73763b33e1"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, int64_t b)</td></tr>
<tr class="separator:a9a64bafd76dd87fefe203a73763b33e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaea6f2cc4dd15dcf82fee93fbde6b5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaea6f2cc4dd15dcf82fee93fbde6b5c"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, int64_t b)</td></tr>
<tr class="separator:acaea6f2cc4dd15dcf82fee93fbde6b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d1db85cdbba355a34f72986d4fb1d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4d1db85cdbba355a34f72986d4fb1d1"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, int64_t b)</td></tr>
<tr class="separator:ae4d1db85cdbba355a34f72986d4fb1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731bf3fbf053930fc547d11426c90f30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a731bf3fbf053930fc547d11426c90f30"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (<a class="el" href="structc10_1_1_half.html">Half</a> a, int64_t b)</td></tr>
<tr class="separator:a731bf3fbf053930fc547d11426c90f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8377ac0c67a79233d8f407ff55af768a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8377ac0c67a79233d8f407ff55af768a"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (int64_t a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a8377ac0c67a79233d8f407ff55af768a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87905b85612bd74fdcf8f07c1330a00f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87905b85612bd74fdcf8f07c1330a00f"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (int64_t a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a87905b85612bd74fdcf8f07c1330a00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b71238703fe1a63ecca8aad786fc195"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b71238703fe1a63ecca8aad786fc195"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (int64_t a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a5b71238703fe1a63ecca8aad786fc195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa849abc83b0b29e1bc4f94437880ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fa849abc83b0b29e1bc4f94437880ee"></a>
C10_HOST_DEVICE <a class="el" href="structc10_1_1_half.html">Half</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (int64_t a, <a class="el" href="structc10_1_1_half.html">Half</a> b)</td></tr>
<tr class="separator:a9fa849abc83b0b29e1bc4f94437880ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecc99848483e645eeaef1521fecebae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ecc99848483e645eeaef1521fecebae"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structc10_1_1_half.html">Half</a> &amp;value)</td></tr>
<tr class="separator:a9ecc99848483e645eeaef1521fecebae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfabc0f4cd2030c8820313a187dcbe4f"><td class="memTemplParams" colspan="2"><a class="anchor" id="adfabc0f4cd2030c8820313a187dcbe4f"></a>
template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:adfabc0f4cd2030c8820313a187dcbe4f"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert</b> (From from)</td></tr>
<tr class="separator:adfabc0f4cd2030c8820313a187dcbe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36257f5c993770cea631906561673646"><td class="memTemplParams" colspan="2"><a class="anchor" id="a36257f5c993770cea631906561673646"></a>
template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a36257f5c993770cea631906561673646"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; From &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>overflows</b> (From f)</td></tr>
<tr class="separator:a36257f5c993770cea631906561673646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ce6db91012a56ce5304cd73bf42cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a636ce6db91012a56ce5304cd73bf42cb"></a>
template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a636ce6db91012a56ce5304cd73bf42cb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; From &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>overflows</b> (From f)</td></tr>
<tr class="separator:a636ce6db91012a56ce5304cd73bf42cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffcdb79bfc59e136a3c057d30362b04"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ffcdb79bfc59e136a3c057d30362b04"></a>
template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a2ffcdb79bfc59e136a3c057d30362b04"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structc10_1_1is__complex__t.html">is_complex_t</a>&lt; From &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>overflows</b> (From f)</td></tr>
<tr class="separator:a2ffcdb79bfc59e136a3c057d30362b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa25f84cd8710447da3ae8b18ef7f36"><td class="memTemplParams" colspan="2"><a class="anchor" id="adfa25f84cd8710447da3ae8b18ef7f36"></a>
template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:adfa25f84cd8710447da3ae8b18ef7f36"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><b>checked_convert</b> (From f, const char *name)</td></tr>
<tr class="separator:adfa25f84cd8710447da3ae8b18ef7f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf56208cc45729f6733862163f075b77"><td class="memTemplParams" colspan="2"><a class="anchor" id="acf56208cc45729f6733862163f075b77"></a>
template&lt;class TTarget , class NullType  = detail::intrusive_target_default_null_type&lt;TTarget&gt;, class... Args&gt; </td></tr>
<tr class="memitem:acf56208cc45729f6733862163f075b77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget, NullType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_intrusive</b> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:acf56208cc45729f6733862163f075b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7e0bb186a8f88efafaeba309932ae4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e7e0bb186a8f88efafaeba309932ae4"></a>
template&lt;class TTarget , class NullType &gt; </td></tr>
<tr class="memitem:a4e7e0bb186a8f88efafaeba309932ae4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget, NullType &gt; &amp;lhs, <a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget, NullType &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a4e7e0bb186a8f88efafaeba309932ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5126107bb9e97460d1d620716f858c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5c5126107bb9e97460d1d620716f858c"></a>
template&lt;class TTarget1 , class NullType1 , class TTarget2 , class NullType2 &gt; </td></tr>
<tr class="memitem:a5c5126107bb9e97460d1d620716f858c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget1, NullType1 &gt; &amp;lhs, const <a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget2, NullType2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a5c5126107bb9e97460d1d620716f858c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a8427a9121802e640c23767a99e04e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8a8427a9121802e640c23767a99e04e"></a>
template&lt;class TTarget1 , class NullType1 , class TTarget2 , class NullType2 &gt; </td></tr>
<tr class="memitem:af8a8427a9121802e640c23767a99e04e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget1, NullType1 &gt; &amp;lhs, const <a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget2, NullType2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:af8a8427a9121802e640c23767a99e04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838f487ffed984661cd65243a8e92e91"><td class="memTemplParams" colspan="2"><a class="anchor" id="a838f487ffed984661cd65243a8e92e91"></a>
template&lt;class TTarget1 , class NullType1 , class TTarget2 , class NullType2 &gt; </td></tr>
<tr class="memitem:a838f487ffed984661cd65243a8e92e91"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget1, NullType1 &gt; &amp;lhs, const <a class="el" href="classc10_1_1intrusive__ptr.html">intrusive_ptr</a>&lt; TTarget2, NullType2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a838f487ffed984661cd65243a8e92e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d493f40adc15eefd08e041c7cba7ae"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa1d493f40adc15eefd08e041c7cba7ae"></a>
template&lt;class TTarget , class NullType &gt; </td></tr>
<tr class="memitem:aa1d493f40adc15eefd08e041c7cba7ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; TTarget, NullType &gt; &amp;lhs, <a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; TTarget, NullType &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aa1d493f40adc15eefd08e041c7cba7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d944a6b60ad309cb321e2e3ce06215"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60d944a6b60ad309cb321e2e3ce06215"></a>
template&lt;class TTarget1 , class NullType1 , class TTarget2 , class NullType2 &gt; </td></tr>
<tr class="memitem:a60d944a6b60ad309cb321e2e3ce06215"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; TTarget1, NullType1 &gt; &amp;lhs, const <a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; TTarget2, NullType2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a60d944a6b60ad309cb321e2e3ce06215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d823a97d449c6746c1a869121a2b18f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8d823a97d449c6746c1a869121a2b18f"></a>
template&lt;class TTarget1 , class NullType1 , class TTarget2 , class NullType2 &gt; </td></tr>
<tr class="memitem:a8d823a97d449c6746c1a869121a2b18f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; TTarget1, NullType1 &gt; &amp;lhs, const <a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; TTarget2, NullType2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:a8d823a97d449c6746c1a869121a2b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa775cf7c47ba4320bc8ad30d5aafd5f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa775cf7c47ba4320bc8ad30d5aafd5f"></a>
template&lt;class TTarget1 , class NullType1 , class TTarget2 , class NullType2 &gt; </td></tr>
<tr class="memitem:aaa775cf7c47ba4320bc8ad30d5aafd5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; TTarget1, NullType1 &gt; &amp;lhs, const <a class="el" href="classc10_1_1weak__intrusive__ptr.html">weak_intrusive_ptr</a>&lt; TTarget2, NullType2 &gt; &amp;rhs) noexcept</td></tr>
<tr class="separator:aaa775cf7c47ba4320bc8ad30d5aafd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1a54d29b26ffd6634620a8d3f3eed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a1a54d29b26ffd6634620a8d3f3eed6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetStackTraceFetcher</b> (std::function&lt; string(void)&gt; fetcher)</td></tr>
<tr class="separator:a0a1a54d29b26ffd6634620a8d3f3eed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17007978d6b54f3e0894f0ad6cace0fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17007978d6b54f3e0894f0ad6cace0fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ThrowEnforceNotMet</b> (const char *file, const int line, const char *condition, const std::string &amp;msg, const void *caller)</td></tr>
<tr class="separator:a17007978d6b54f3e0894f0ad6cace0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1209ce0468690b39d9865eaf48d7c43d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1209ce0468690b39d9865eaf48d7c43d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>InitCaffeLogging</b> (int *argc, char **argv)</td></tr>
<tr class="separator:a1209ce0468690b39d9865eaf48d7c43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d072249f6afdaf88b3b8e40d153bbd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2d072249f6afdaf88b3b8e40d153bbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UpdateLoggingLevelsFromFlags</b> ()</td></tr>
<tr class="separator:af2d072249f6afdaf88b3b8e40d153bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a77b8ab825db155ab44df79e49a25e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a01a77b8ab825db155ab44df79e49a25e">ShowLogInfoToStderr</a> ()</td></tr>
<tr class="memdesc:a01a77b8ab825db155ab44df79e49a25e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> utility to allow one to show log info to stderr after the program starts.  <a href="#a01a77b8ab825db155ab44df79e49a25e">More...</a><br /></td></tr>
<tr class="separator:a01a77b8ab825db155ab44df79e49a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf77c8c202705cfff70e1b040b4260c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf77c8c202705cfff70e1b040b4260c2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsUsingGoogleLogging</b> ()</td></tr>
<tr class="separator:aaf77c8c202705cfff70e1b040b4260c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4635abd51d5114318ec01815cf558c6b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4635abd51d5114318ec01815cf558c6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4635abd51d5114318ec01815cf558c6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LogMessageFatal</b> (const char *file, int line, const <a class="el" href="struct_t.html">T</a> &amp;message)</td></tr>
<tr class="separator:a4635abd51d5114318ec01815cf558c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcd3e53b9cf7516eb41e0eea3b022d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8fcd3e53b9cf7516eb41e0eea3b022d5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8fcd3e53b9cf7516eb41e0eea3b022d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_t.html">T</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNullCommon</b> (const char *file, int line, const char *names, <a class="el" href="struct_t.html">T</a> &amp;t)</td></tr>
<tr class="separator:a8fcd3e53b9cf7516eb41e0eea3b022d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f77bcd6cdc7edbf7d5c584c40b20685"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f77bcd6cdc7edbf7d5c584c40b20685"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f77bcd6cdc7edbf7d5c584c40b20685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_t.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNull</b> (const char *file, int line, const char *names, <a class="el" href="struct_t.html">T</a> *t)</td></tr>
<tr class="separator:a5f77bcd6cdc7edbf7d5c584c40b20685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537aacbf092740934992797cede062c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a537aacbf092740934992797cede062c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a537aacbf092740934992797cede062c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_t.html">T</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNull</b> (const char *file, int line, const char *names, <a class="el" href="struct_t.html">T</a> &amp;t)</td></tr>
<tr class="separator:a537aacbf092740934992797cede062c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7b41d9b4efa91d0e390221281af46a"><td class="memTemplParams" colspan="2"><a class="anchor" id="add7b41d9b4efa91d0e390221281af46a"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:add7b41d9b4efa91d0e390221281af46a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrintSequence</b> (std::ostream &amp;ss, Iter begin, Iter end)</td></tr>
<tr class="separator:add7b41d9b4efa91d0e390221281af46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4960c771d482743797d67a7f996ac91f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4960c771d482743797d67a7f996ac91f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a4960c771d482743797d67a7f996ac91f">IsNUMAEnabled</a> ()</td></tr>
<tr class="memdesc:a4960c771d482743797d67a7f996ac91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether NUMA is enabled. <br /></td></tr>
<tr class="separator:a4960c771d482743797d67a7f996ac91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752103bd4d6ed466c60fff08afb0f4f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a752103bd4d6ed466c60fff08afb0f4f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a752103bd4d6ed466c60fff08afb0f4f9">NUMABind</a> (int numa_node_id)</td></tr>
<tr class="memdesc:a752103bd4d6ed466c60fff08afb0f4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a given NUMA node. <br /></td></tr>
<tr class="separator:a752103bd4d6ed466c60fff08afb0f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accbad04dbab7c8538591d0dd6ee6bb6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accbad04dbab7c8538591d0dd6ee6bb6b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#accbad04dbab7c8538591d0dd6ee6bb6b">GetNUMANode</a> (const void *ptr)</td></tr>
<tr class="memdesc:accbad04dbab7c8538591d0dd6ee6bb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the NUMA id for a given pointer <code>ptr</code> <br /></td></tr>
<tr class="separator:accbad04dbab7c8538591d0dd6ee6bb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc75f1456c338101af3a87ca531570f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc75f1456c338101af3a87ca531570f8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#afc75f1456c338101af3a87ca531570f8">GetNumNUMANodes</a> ()</td></tr>
<tr class="memdesc:afc75f1456c338101af3a87ca531570f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of NUMA nodes. <br /></td></tr>
<tr class="separator:afc75f1456c338101af3a87ca531570f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd960fd630f4cae48f6576bf2e8a613"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bd960fd630f4cae48f6576bf2e8a613"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a7bd960fd630f4cae48f6576bf2e8a613">NUMAMove</a> (void *ptr, size_t size, int numa_node_id)</td></tr>
<tr class="memdesc:a7bd960fd630f4cae48f6576bf2e8a613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the memory pointed to by <code>ptr</code> of a given size to another NUMA node. <br /></td></tr>
<tr class="separator:a7bd960fd630f4cae48f6576bf2e8a613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af868252b9aad26103fd515e1cf6e3917"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af868252b9aad26103fd515e1cf6e3917"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#af868252b9aad26103fd515e1cf6e3917">GetCurrentNUMANode</a> ()</td></tr>
<tr class="memdesc:af868252b9aad26103fd515e1cf6e3917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current NUMA node id. <br /></td></tr>
<tr class="separator:af868252b9aad26103fd515e1cf6e3917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383b62f56456ff8cb8e9f089be70d49"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad383b62f56456ff8cb8e9f089be70d49"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad383b62f56456ff8cb8e9f089be70d49"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_t.html">T</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constexpr_forward</b> (typename std::remove_reference&lt; <a class="el" href="struct_t.html">T</a> &gt;::type &amp;t) noexcept</td></tr>
<tr class="separator:ad383b62f56456ff8cb8e9f089be70d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0f359ffd33e6d40971afb99c5f2903"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a0f359ffd33e6d40971afb99c5f2903"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a0f359ffd33e6d40971afb99c5f2903"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_t.html">T</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constexpr_forward</b> (typename std::remove_reference&lt; <a class="el" href="struct_t.html">T</a> &gt;::type &amp;&amp;t) noexcept</td></tr>
<tr class="separator:a5a0f359ffd33e6d40971afb99c5f2903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a270bd4854d520ee2a8e045bb1565a356"><td class="memTemplParams" colspan="2"><a class="anchor" id="a270bd4854d520ee2a8e045bb1565a356"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a270bd4854d520ee2a8e045bb1565a356"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_reference&lt; <a class="el" href="struct_t.html">T</a> &gt;::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constexpr_move</b> (<a class="el" href="struct_t.html">T</a> &amp;&amp;t) noexcept</td></tr>
<tr class="separator:a270bd4854d520ee2a8e045bb1565a356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af577e93be6e3da907ac100d016a2aec0"><td class="memTemplParams" colspan="2"><a class="anchor" id="af577e93be6e3da907ac100d016a2aec0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af577e93be6e3da907ac100d016a2aec0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;y)</td></tr>
<tr class="separator:af577e93be6e3da907ac100d016a2aec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e78a39dd40a4e3ded23fd41f34a28"><td class="memTemplParams" colspan="2"><a class="anchor" id="a093e78a39dd40a4e3ded23fd41f34a28"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a093e78a39dd40a4e3ded23fd41f34a28"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;y)</td></tr>
<tr class="separator:a093e78a39dd40a4e3ded23fd41f34a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26ac421a4b676bf779f3dd4305108a2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac26ac421a4b676bf779f3dd4305108a2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac26ac421a4b676bf779f3dd4305108a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;y)</td></tr>
<tr class="separator:ac26ac421a4b676bf779f3dd4305108a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3382369bf47f02992c0b4b70ae6a54bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3382369bf47f02992c0b4b70ae6a54bb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3382369bf47f02992c0b4b70ae6a54bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;y)</td></tr>
<tr class="separator:a3382369bf47f02992c0b4b70ae6a54bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd3ee4e02b43ff797d67626c5ef4c07"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2fd3ee4e02b43ff797d67626c5ef4c07"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2fd3ee4e02b43ff797d67626c5ef4c07"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;y)</td></tr>
<tr class="separator:a2fd3ee4e02b43ff797d67626c5ef4c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2caef1f7b1456d5c9a5a35f51596753"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2caef1f7b1456d5c9a5a35f51596753"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac2caef1f7b1456d5c9a5a35f51596753"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;y)</td></tr>
<tr class="separator:ac2caef1f7b1456d5c9a5a35f51596753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e710caadc4964bc02158bded666c55b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e710caadc4964bc02158bded666c55b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8e710caadc4964bc02158bded666c55b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, <a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a8e710caadc4964bc02158bded666c55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d58fcdb7502811e276b57606f1bda2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a80d58fcdb7502811e276b57606f1bda2"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a80d58fcdb7502811e276b57606f1bda2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (<a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x) noexcept</td></tr>
<tr class="separator:a80d58fcdb7502811e276b57606f1bda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50df1ef0b829d10d1933655d1c2384b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a50df1ef0b829d10d1933655d1c2384b5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a50df1ef0b829d10d1933655d1c2384b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, <a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a50df1ef0b829d10d1933655d1c2384b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e0864ef7494a1d8d50a4b76a305bb5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62e0864ef7494a1d8d50a4b76a305bb5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a62e0864ef7494a1d8d50a4b76a305bb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (<a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x) noexcept</td></tr>
<tr class="separator:a62e0864ef7494a1d8d50a4b76a305bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346e4d4ad602b1b1ebcab28a072b83d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a346e4d4ad602b1b1ebcab28a072b83d4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a346e4d4ad602b1b1ebcab28a072b83d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;, <a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a346e4d4ad602b1b1ebcab28a072b83d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae236db74cbc6f0c4cb8afeff2cd4219"><td class="memTemplParams" colspan="2"><a class="anchor" id="aae236db74cbc6f0c4cb8afeff2cd4219"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aae236db74cbc6f0c4cb8afeff2cd4219"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (<a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x) noexcept</td></tr>
<tr class="separator:aae236db74cbc6f0c4cb8afeff2cd4219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd35238c77d275d57543a018f41934f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fd35238c77d275d57543a018f41934f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1fd35238c77d275d57543a018f41934f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, <a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a1fd35238c77d275d57543a018f41934f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63f986e22ff6277e30f34d97df79d47"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab63f986e22ff6277e30f34d97df79d47"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab63f986e22ff6277e30f34d97df79d47"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (<a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;) noexcept</td></tr>
<tr class="separator:ab63f986e22ff6277e30f34d97df79d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0f4a49f5b103f5cde1d85e312f1bfb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f0f4a49f5b103f5cde1d85e312f1bfb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f0f4a49f5b103f5cde1d85e312f1bfb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, <a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a1f0f4a49f5b103f5cde1d85e312f1bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd852c1da539a3282faaa506e105199"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9bd852c1da539a3282faaa506e105199"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9bd852c1da539a3282faaa506e105199"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (<a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;) noexcept</td></tr>
<tr class="separator:a9bd852c1da539a3282faaa506e105199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4483cbb07d8db82319a9913ccf7839f5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4483cbb07d8db82319a9913ccf7839f5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4483cbb07d8db82319a9913ccf7839f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;, <a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>) noexcept</td></tr>
<tr class="separator:a4483cbb07d8db82319a9913ccf7839f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3347acd55c607deaf14ee4fa40054e45"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3347acd55c607deaf14ee4fa40054e45"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3347acd55c607deaf14ee4fa40054e45"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (<a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x) noexcept</td></tr>
<tr class="separator:a3347acd55c607deaf14ee4fa40054e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd7fa36d5dee41d26f1efb4a65e7f61"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7dd7fa36d5dee41d26f1efb4a65e7f61"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7dd7fa36d5dee41d26f1efb4a65e7f61"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a7dd7fa36d5dee41d26f1efb4a65e7f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e2dd64e1f1dee60065ee8f608d0711"><td class="memTemplParams" colspan="2"><a class="anchor" id="a45e2dd64e1f1dee60065ee8f608d0711"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a45e2dd64e1f1dee60065ee8f608d0711"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x)</td></tr>
<tr class="separator:a45e2dd64e1f1dee60065ee8f608d0711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8accc0b59357fb90091ef65f2692c4d"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8accc0b59357fb90091ef65f2692c4d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af8accc0b59357fb90091ef65f2692c4d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:af8accc0b59357fb90091ef65f2692c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e300ffa48b067e522fd823c65ce063"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22e300ffa48b067e522fd823c65ce063"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a22e300ffa48b067e522fd823c65ce063"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x)</td></tr>
<tr class="separator:a22e300ffa48b067e522fd823c65ce063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d618c4c0bd1bbd1017a3c742fd79433"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3d618c4c0bd1bbd1017a3c742fd79433"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3d618c4c0bd1bbd1017a3c742fd79433"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a3d618c4c0bd1bbd1017a3c742fd79433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ed8aaf60ec548eabd322d66cae73d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4ed8aaf60ec548eabd322d66cae73d3"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab4ed8aaf60ec548eabd322d66cae73d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x)</td></tr>
<tr class="separator:ab4ed8aaf60ec548eabd322d66cae73d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad950449e6024b9deef59cd85000ffe97"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad950449e6024b9deef59cd85000ffe97"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad950449e6024b9deef59cd85000ffe97"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:ad950449e6024b9deef59cd85000ffe97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb96649be9451ba934b0a9e5e000e7d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb96649be9451ba934b0a9e5e000e7d7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afb96649be9451ba934b0a9e5e000e7d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x)</td></tr>
<tr class="separator:afb96649be9451ba934b0a9e5e000e7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8d58ee219d38d8f0d933dfb7f23db0"><td class="memTemplParams" colspan="2"><a class="anchor" id="afc8d58ee219d38d8f0d933dfb7f23db0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afc8d58ee219d38d8f0d933dfb7f23db0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:afc8d58ee219d38d8f0d933dfb7f23db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7967c654252e0deefb4f7681d0a4d1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7967c654252e0deefb4f7681d0a4d1d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa7967c654252e0deefb4f7681d0a4d1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x)</td></tr>
<tr class="separator:aa7967c654252e0deefb4f7681d0a4d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8283ccbd2d4aad9311e91f001cd26b76"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8283ccbd2d4aad9311e91f001cd26b76"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a8283ccbd2d4aad9311e91f001cd26b76"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a8283ccbd2d4aad9311e91f001cd26b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f6e4af40d70b40a2107d2dccce2e07"><td class="memTemplParams" colspan="2"><a class="anchor" id="a90f6e4af40d70b40a2107d2dccce2e07"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a90f6e4af40d70b40a2107d2dccce2e07"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x)</td></tr>
<tr class="separator:a90f6e4af40d70b40a2107d2dccce2e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4b6aa61d0a1681e5c2c60f95983016"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca4b6aa61d0a1681e5c2c60f95983016"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aca4b6aa61d0a1681e5c2c60f95983016"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:aca4b6aa61d0a1681e5c2c60f95983016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc49fa855bdc9efb1bca6821c643d624"><td class="memTemplParams" colspan="2"><a class="anchor" id="acc49fa855bdc9efb1bca6821c643d624"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acc49fa855bdc9efb1bca6821c643d624"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:acc49fa855bdc9efb1bca6821c643d624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529036e89f22edec3a0515916a0086b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a529036e89f22edec3a0515916a0086b6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a529036e89f22edec3a0515916a0086b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a529036e89f22edec3a0515916a0086b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18527bd51c4db56951cddceafa263ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae18527bd51c4db56951cddceafa263ca"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae18527bd51c4db56951cddceafa263ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:ae18527bd51c4db56951cddceafa263ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a333de387baffb838a024a47def4d04"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1a333de387baffb838a024a47def4d04"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1a333de387baffb838a024a47def4d04"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a1a333de387baffb838a024a47def4d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2561e58311a70cd6e2ea18d54e7c790e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2561e58311a70cd6e2ea18d54e7c790e"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2561e58311a70cd6e2ea18d54e7c790e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:a2561e58311a70cd6e2ea18d54e7c790e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf9179d214d8311954c240f339f6a54"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4cf9179d214d8311954c240f339f6a54"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4cf9179d214d8311954c240f339f6a54"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a4cf9179d214d8311954c240f339f6a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3396be5a3bcca36f5ba3e8bbd60acf1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3396be5a3bcca36f5ba3e8bbd60acf1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac3396be5a3bcca36f5ba3e8bbd60acf1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:ac3396be5a3bcca36f5ba3e8bbd60acf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275f44884ab3ad174e645e02d804f4f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a275f44884ab3ad174e645e02d804f4f0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a275f44884ab3ad174e645e02d804f4f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a275f44884ab3ad174e645e02d804f4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ae9fdbe406a52fca8c6b0ec9089a98"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac6ae9fdbe406a52fca8c6b0ec9089a98"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac6ae9fdbe406a52fca8c6b0ec9089a98"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:ac6ae9fdbe406a52fca8c6b0ec9089a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc23b1b58970b648256d6ad29bea7b7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9bc23b1b58970b648256d6ad29bea7b7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9bc23b1b58970b648256d6ad29bea7b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a9bc23b1b58970b648256d6ad29bea7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309410bc4f11f10c0b77bcb5fca766a0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a309410bc4f11f10c0b77bcb5fca766a0"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a309410bc4f11f10c0b77bcb5fca766a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:a309410bc4f11f10c0b77bcb5fca766a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfe4b5646ac98118c4418dabe90a716"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3cfe4b5646ac98118c4418dabe90a716"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3cfe4b5646ac98118c4418dabe90a716"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a3cfe4b5646ac98118c4418dabe90a716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43dec6cb22172dcb4596b22ec1fd1ef4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43dec6cb22172dcb4596b22ec1fd1ef4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a43dec6cb22172dcb4596b22ec1fd1ef4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:a43dec6cb22172dcb4596b22ec1fd1ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcabfaa0b0266df189bdb6539651f0f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5dcabfaa0b0266df189bdb6539651f0f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5dcabfaa0b0266df189bdb6539651f0f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a5dcabfaa0b0266df189bdb6539651f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb7207ce7825f71afc6a188195dcfdd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2bb7207ce7825f71afc6a188195dcfdd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a2bb7207ce7825f71afc6a188195dcfdd"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:a2bb7207ce7825f71afc6a188195dcfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47f25e4099126a6e1e6f6be37ee9dfa"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab47f25e4099126a6e1e6f6be37ee9dfa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab47f25e4099126a6e1e6f6be37ee9dfa"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:ab47f25e4099126a6e1e6f6be37ee9dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d9fd85c365fb5276e92cce30d4364b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a91d9fd85c365fb5276e92cce30d4364b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a91d9fd85c365fb5276e92cce30d4364b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:a91d9fd85c365fb5276e92cce30d4364b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af419f9c16dd01c77b3313c6774a03d62"><td class="memTemplParams" colspan="2"><a class="anchor" id="af419f9c16dd01c77b3313c6774a03d62"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af419f9c16dd01c77b3313c6774a03d62"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:af419f9c16dd01c77b3313c6774a03d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54898a8cc36872ca6ff4d841dae37219"><td class="memTemplParams" colspan="2"><a class="anchor" id="a54898a8cc36872ca6ff4d841dae37219"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a54898a8cc36872ca6ff4d841dae37219"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:a54898a8cc36872ca6ff4d841dae37219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4f3f16f4b94416d13fa346bd11e74f"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab4f3f16f4b94416d13fa346bd11e74f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aab4f3f16f4b94416d13fa346bd11e74f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:aab4f3f16f4b94416d13fa346bd11e74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550a9bdcca847305808b7714a5d21fcf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a550a9bdcca847305808b7714a5d21fcf"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a550a9bdcca847305808b7714a5d21fcf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:a550a9bdcca847305808b7714a5d21fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad66c9953fd27741a15d2834e9bc6bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9ad66c9953fd27741a15d2834e9bc6bb"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a9ad66c9953fd27741a15d2834e9bc6bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x, const <a class="el" href="struct_t.html">T</a> &amp;v)</td></tr>
<tr class="separator:a9ad66c9953fd27741a15d2834e9bc6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4490b9198c5a138463a29f8aafb5d67b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4490b9198c5a138463a29f8aafb5d67b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4490b9198c5a138463a29f8aafb5d67b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="struct_t.html">T</a> &amp;v, const <a class="el" href="classc10_1_1optional.html">optional</a>&lt; const <a class="el" href="struct_t.html">T</a> &amp; &gt; &amp;x)</td></tr>
<tr class="separator:a4490b9198c5a138463a29f8aafb5d67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2deed5ecd6ef9aaacd1d611c105e7a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2deed5ecd6ef9aaacd1d611c105e7a6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af2deed5ecd6ef9aaacd1d611c105e7a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;x, <a class="el" href="classc10_1_1optional.html">optional</a>&lt; <a class="el" href="struct_t.html">T</a> &gt; &amp;y) noexcept(noexcept(x.swap(y)))</td></tr>
<tr class="separator:af2deed5ecd6ef9aaacd1d611c105e7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7407b86d00633661d656c6260df94a61"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7407b86d00633661d656c6260df94a61"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7407b86d00633661d656c6260df94a61"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classc10_1_1optional.html">optional</a>&lt; typename std::decay&lt; <a class="el" href="struct_t.html">T</a> &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_optional</b> (<a class="el" href="struct_t.html">T</a> &amp;&amp;v)</td></tr>
<tr class="separator:a7407b86d00633661d656c6260df94a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef559b939b814bb1f95cc007f4378e08"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef559b939b814bb1f95cc007f4378e08"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:aef559b939b814bb1f95cc007f4378e08"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classc10_1_1optional.html">optional</a>&lt; X &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_optional</b> (std::reference_wrapper&lt; X &gt; v)</td></tr>
<tr class="separator:aef559b939b814bb1f95cc007f4378e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e37d325683507e9ec30a73b0a98db8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34e37d325683507e9ec30a73b0a98db8"></a>
template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:a34e37d325683507e9ec30a73b0a98db8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KeyStrRepr</b> (const KeyType &amp;)</td></tr>
<tr class="separator:a34e37d325683507e9ec30a73b0a98db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25038b275b3eb8224808f726d0a7c7b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac25038b275b3eb8224808f726d0a7c7b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac25038b275b3eb8224808f726d0a7c7b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KeyStrRepr</b> (const std::string &amp;key)</td></tr>
<tr class="separator:ac25038b275b3eb8224808f726d0a7c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94b43f37fb4a5de74d419c41b9de3b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae94b43f37fb4a5de74d419c41b9de3b5"></a>
template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:ae94b43f37fb4a5de74d419c41b9de3b5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>capacity_in_bytes</b> (const <a class="el" href="classc10_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="struct_t.html">T</a>, N &gt; &amp;X)</td></tr>
<tr class="separator:ae94b43f37fb4a5de74d419c41b9de3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97d94b076aa64c036529ad95210abac"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab97d94b076aa64c036529ad95210abac"></a>
template&lt;typename T , unsigned N&gt; </td></tr>
<tr class="memitem:ab97d94b076aa64c036529ad95210abac"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classc10_1_1_small_vector.html">SmallVector</a>&lt; <a class="el" href="struct_t.html">T</a>, N &gt; &amp;list)</td></tr>
<tr class="separator:ab97d94b076aa64c036529ad95210abac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33edcb7e38beb77568ea3b6fabf5fcc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33edcb7e38beb77568ea3b6fabf5fcc8"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="structc10_1_1_source_location.html">SourceLocation</a> &amp;loc)</td></tr>
<tr class="separator:a33edcb7e38beb77568ea3b6fabf5fcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd801996be7fc9b3a871fefd0ac8765"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cd801996be7fc9b3a871fefd0ac8765"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceAll</b> (std::string &amp;s, const char *from, const char *to)</td></tr>
<tr class="separator:a4cd801996be7fc9b3a871fefd0ac8765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5b5614ef9e8e50c07bbda22223ab95"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7b5b5614ef9e8e50c07bbda22223ab95"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7b5b5614ef9e8e50c07bbda22223ab95"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str</b> (const Args &amp;...args)</td></tr>
<tr class="separator:a7b5b5614ef9e8e50c07bbda22223ab95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ca7219d98bfc1fbfc65815621e6dc6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5ca7219d98bfc1fbfc65815621e6dc6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa5ca7219d98bfc1fbfc65815621e6dc6"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>str</b> (const std::string &amp;str)</td></tr>
<tr class="separator:aa5ca7219d98bfc1fbfc65815621e6dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f05e81183783e3e26b0105cecd0950b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f05e81183783e3e26b0105cecd0950b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>str</b> (const char *c_str)</td></tr>
<tr class="separator:a0f05e81183783e3e26b0105cecd0950b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d02e4e99d84f30c5520b80148b57e23"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d02e4e99d84f30c5520b80148b57e23"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a4d02e4e99d84f30c5520b80148b57e23"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Join</b> (const std::string &amp;delimiter, const Container &amp;v)</td></tr>
<tr class="separator:a4d02e4e99d84f30c5520b80148b57e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a54dde60c980b594d86c402ebd3e7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classc10_1_1optional.html">c10::optional</a>&lt; <a class="el" href="structc10_1_1_temp_file.html">TempFile</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#ad0a54dde60c980b594d86c402ebd3e7f">try_make_tempfile</a> (std::string name_prefix=&quot;torch-file-&quot;)</td></tr>
<tr class="memdesc:ad0a54dde60c980b594d86c402ebd3e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to return a temporary file or returns <code>nullopt</code> if an error ocurred.  <a href="#ad0a54dde60c980b594d86c402ebd3e7f">More...</a><br /></td></tr>
<tr class="separator:ad0a54dde60c980b594d86c402ebd3e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f6ad44d4802580d666e93ba4fd6259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structc10_1_1_temp_file.html">TempFile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a14f6ad44d4802580d666e93ba4fd6259">make_tempfile</a> (std::string name_prefix=&quot;torch-file-&quot;)</td></tr>
<tr class="memdesc:a14f6ad44d4802580d666e93ba4fd6259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <code>try_make_tempfile</code>, but throws an exception if a temporary file could not be returned.  <a href="#a14f6ad44d4802580d666e93ba4fd6259">More...</a><br /></td></tr>
<tr class="separator:a14f6ad44d4802580d666e93ba4fd6259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765e5f91f133351fed2a04ea4b82116a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a765e5f91f133351fed2a04ea4b82116a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setThreadName</b> (std::string name)</td></tr>
<tr class="separator:a765e5f91f133351fed2a04ea4b82116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103edec35d888a4d657a84c7a5da0b8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a103edec35d888a4d657a84c7a5da0b8b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacec10.html#a103edec35d888a4d657a84c7a5da0b8b">demangle</a> (const char *name)</td></tr>
<tr class="memdesc:a103edec35d888a4d657a84c7a5da0b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to demangle a C++ symbol name. <br /></td></tr>
<tr class="separator:a103edec35d888a4d657a84c7a5da0b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc154747f3775649649c79ba44657ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9bc154747f3775649649c79ba44657ba"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bc154747f3775649649c79ba44657ba"><td class="memTemplItemLeft" align="right" valign="top">const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacec10.html#a9bc154747f3775649649c79ba44657ba">demangle_type</a> ()</td></tr>
<tr class="memdesc:a9bc154747f3775649649c79ba44657ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the printable name of the type. <br /></td></tr>
<tr class="separator:a9bc154747f3775649649c79ba44657ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe654c39d3f40ce3950fe6c7889b848f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe654c39d3f40ce3950fe6c7889b848f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_REGISTER_CREATOR</b> (ThreadPoolRegistry, CPU, caffe2::GetAsyncNetThreadPool&lt; <a class="el" href="classc10_1_1_task_thread_pool.html">TaskThreadPool</a>, caffe2::PROTO_CPU &gt;)</td></tr>
<tr class="separator:afe654c39d3f40ce3950fe6c7889b848f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df2282d5f72f3ee05e3d04f170f7542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8df2282d5f72f3ee05e3d04f170f7542"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_REGISTER_CREATOR</b> (ThreadPoolRegistry, CUDA, caffe2::GetAsyncNetThreadPool&lt; <a class="el" href="classc10_1_1_task_thread_pool.html">TaskThreadPool</a>, caffe2::PROTO_CUDA &gt;)</td></tr>
<tr class="separator:a8df2282d5f72f3ee05e3d04f170f7542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ed0eeab41e21fd4ab2ab60d90b81a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20ed0eeab41e21fd4ab2ab60d90b81a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>C10_REGISTER_CREATOR</b> (ThreadPoolRegistry, HIP, caffe2::GetAsyncNetThreadPool&lt; <a class="el" href="classc10_1_1_task_thread_pool.html">TaskThreadPool</a>, caffe2::PROTO_HIP &gt;)</td></tr>
<tr class="separator:a20ed0eeab41e21fd4ab2ab60d90b81a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5c9a2545580d8c1df5ad4a86c06049"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b5c9a2545580d8c1df5ad4a86c06049"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kernel&lt; decltype(caffe2::batch_gather_op_cpu),&amp;caffe2::batch_gather_op_cpu &gt;</b> ().dispatchKey(CPUTensorId())</td></tr>
<tr class="separator:a9b5c9a2545580d8c1df5ad4a86c06049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582e76057a3bbbaabfa8ae34f30c942b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a582e76057a3bbbaabfa8ae34f30c942b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kernel&lt; decltype(caffe2::cast_op_cpu),&amp;caffe2::cast_op_cpu &gt;</b> ().dispatchKey(CPUTensorId())</td></tr>
<tr class="separator:a582e76057a3bbbaabfa8ae34f30c942b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64841445e2e17e7bda11a815c13af3f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64841445e2e17e7bda11a815c13af3f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kernel&lt; decltype(caffe2::constant_fill_op_cpu_impl),&amp;caffe2::constant_fill_op_cpu_impl &gt;</b> ().dispatchKey(CPUTensorId())</td></tr>
<tr class="separator:a64841445e2e17e7bda11a815c13af3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e098d3f5bda60991dca06dd0b3aae4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e098d3f5bda60991dca06dd0b3aae4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kernel&lt; decltype(caffe2::uniform_fill_op_cpu_impl),&amp;caffe2::uniform_fill_op_cpu_impl &gt;</b> ().dispatchKey(CPUTensorId())</td></tr>
<tr class="separator:a8e098d3f5bda60991dca06dd0b3aae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50558a92cee1d9a7a11c02ebcd9b45d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50558a92cee1d9a7a11c02ebcd9b45d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kernel&lt; decltype(caffe2::sigmoid_cross_entropy_with_logits_op_cpu_impl),&amp;caffe2::sigmoid_cross_entropy_with_logits_op_cpu_impl &gt;</b> ().dispatchKey(CPUTensorId())</td></tr>
<tr class="separator:a50558a92cee1d9a7a11c02ebcd9b45d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fb0b2564128f6788d3a056ed4e35ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81fb0b2564128f6788d3a056ed4e35ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kernel&lt; decltype(caffe2::sparse_lengths_sum_op_cpu),&amp;caffe2::sparse_lengths_sum_op_cpu &gt;</b> ().dispatchKey(CPUTensorId())</td></tr>
<tr class="separator:a81fb0b2564128f6788d3a056ed4e35ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae26c1880234c9f58a92e8db613169696"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae26c1880234c9f58a92e8db613169696"></a>
class CAFFE2_API&#160;</td><td class="memItemRight" valign="bottom"><b>OperatorHandle</b></td></tr>
<tr class="separator:ae26c1880234c9f58a92e8db613169696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4f272a1ea62fe2bcd994e0b9d82b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f4f272a1ea62fe2bcd994e0b9d82b71"></a>
C10_API <a class="el" href="structc10_1_1_allocator.html">at::Allocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_array</b> [at::COMPILE_TIME_MAX_DEVICE_TYPES]</td></tr>
<tr class="separator:a5f4f272a1ea62fe2bcd994e0b9d82b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abbd48f59b3b454ddb09dc455bb747f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5abbd48f59b3b454ddb09dc455bb747f"></a>
constexpr DeviceType&#160;</td><td class="memItemRight" valign="bottom"><b>kCPU</b> = DeviceType::CPU</td></tr>
<tr class="separator:a5abbd48f59b3b454ddb09dc455bb747f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af612db13bdfcb992355e9610b6f79071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af612db13bdfcb992355e9610b6f79071"></a>
constexpr DeviceType&#160;</td><td class="memItemRight" valign="bottom"><b>kCUDA</b> = DeviceType::CUDA</td></tr>
<tr class="separator:af612db13bdfcb992355e9610b6f79071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a8e007b873f1c3befb138744c092fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4a8e007b873f1c3befb138744c092fd"></a>
constexpr DeviceType&#160;</td><td class="memItemRight" valign="bottom"><b>kHIP</b> = DeviceType::HIP</td></tr>
<tr class="separator:ae4a8e007b873f1c3befb138744c092fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac033016a05862351aee036f27b462121"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac033016a05862351aee036f27b462121"></a>
constexpr DeviceType&#160;</td><td class="memItemRight" valign="bottom"><b>kMSNPU</b> = DeviceType::MSNPU</td></tr>
<tr class="separator:ac033016a05862351aee036f27b462121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e461b32682683e358f0ec6df4a3136f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e461b32682683e358f0ec6df4a3136f"></a>
constexpr DeviceType&#160;</td><td class="memItemRight" valign="bottom"><b>kXLA</b> = DeviceType::XLA</td></tr>
<tr class="separator:a5e461b32682683e358f0ec6df4a3136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9c4abcba7942770bfc1c87b3550b7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad9c4abcba7942770bfc1c87b3550b7d"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>gAlignment</b> = 64</td></tr>
<tr class="separator:aad9c4abcba7942770bfc1c87b3550b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a856f57c37775d4151690b34804dc50"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>COMPILE_TIME_MAX_DEVICE_TYPES</b></td></tr>
<tr class="separator:a6a856f57c37775d4151690b34804dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b04937a9c747afdce8c540b3ea4b71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4b04937a9c747afdce8c540b3ea4b71"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kStrided</b> = Layout::Strided</td></tr>
<tr class="separator:ab4b04937a9c747afdce8c540b3ea4b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177a00fb4c0c63f832be0c0580caf25a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a177a00fb4c0c63f832be0c0580caf25a"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kSparse</b> = Layout::Sparse</td></tr>
<tr class="separator:a177a00fb4c0c63f832be0c0580caf25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8133aa2971b4170c3a61cad80ad3d2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8133aa2971b4170c3a61cad80ad3d2c"></a>
***But this will be problematic Consider&#160;</td><td class="memItemRight" valign="bottom"><b>this</b></td></tr>
<tr class="separator:ab8133aa2971b4170c3a61cad80ad3d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ad47b27779369969cc5074beb920a7"><td class="memItemLeft" align="right" valign="top">***But this will be problematic Consider *Compiler will compain about ambiguity between the copy constructor and the *<a class="el" href="structc10_1_1_device.html">Device</a> constructor&#160;</td><td class="memItemRight" valign="bottom"><b>because</b></td></tr>
<tr class="separator:a81ad47b27779369969cc5074beb920a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5494150a1ab3cdfa73ccc40b27a6a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb5494150a1ab3cdfa73ccc40b27a6a5"></a>
***But this will be problematic Consider *Compiler will compain about ambiguity between the copy constructor and the *<a class="el" href="structc10_1_1_device.html">Device</a> constructor we templatize the <a class="el" href="structc10_1_1_device.html">Device</a> constructor Since overload *resolution is done before template&#160;</td><td class="memItemRight" valign="bottom"><b>resolution</b></td></tr>
<tr class="separator:acb5494150a1ab3cdfa73ccc40b27a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e1c38c8595fa700201c49419085120"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e1c38c8595fa700201c49419085120"></a>
std::atomic&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>num_threads</b> {1}</td></tr>
<tr class="separator:a12e1c38c8595fa700201c49419085120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f18cf522212fec3fc52db59d8a94f45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f18cf522212fec3fc52db59d8a94f45"></a>
constexpr struct <a class="el" href="structc10_1_1trivial__init__t.html">c10::trivial_init_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>trivial_init</b></td></tr>
<tr class="separator:a9f18cf522212fec3fc52db59d8a94f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336d33ab14407e5d1129a191256e8e44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a336d33ab14407e5d1129a191256e8e44"></a>
constexpr struct <a class="el" href="structc10_1_1in__place__t.html">c10::in_place_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>in_place</b></td></tr>
<tr class="separator:a336d33ab14407e5d1129a191256e8e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a512029e2d04c6cee5f0cb857323b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a512029e2d04c6cee5f0cb857323b0"></a>
constexpr <a class="el" href="structc10_1_1nullopt__t.html">nullopt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nullopt</b> {<a class="el" href="structc10_1_1nullopt__t_1_1init.html">nullopt_t::init</a>()}</td></tr>
<tr class="separator:a50a512029e2d04c6cee5f0cb857323b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>To register your own kernel for an operator, do in one (!) cpp file: C10_REGISTER_KERNEL(OperatorHandle) .kernel&lt;decltype(&amp;kernel_func), &amp;kernel_func&gt;() .dispatchKey(dispatch_key);. </p>
<p>Simple registry implementation that uses static variables to register object creators during program initialization time.</p>
<p>Defines the <a class="el" href="structc10_1_1_half.html">Half</a> type (half-precision floating-point) including conversions to standard <a class="el" href="struct_c.html">C</a> types and basic arithmetic operations.</p>
<p>This file is based on the std::array implementation of libstdc++ at <a href="https://gcc.gnu.org/onlinedocs/gcc-7.1.0/libstdc++/api/a01056_source.html">https://gcc.gnu.org/onlinedocs/gcc-7.1.0/libstdc++/api/a01056_source.html</a>.</p>
<p>To register your own tensor types, do in a header file: C10_DECLARE_TENSOR_TYPE(MY_TENSOR) and in one (!) cpp file: C10_DEFINE_TENSOR_TYPE(MY_TENSOR) Both must be in the same namespace.</p>
<p>Example:</p>
<p><a class="el" href="struct_tensor.html">Tensor</a> my_kernel_cpu(Tensor in) {...}</p>
<p>C10_REGISTER_KERNEL(MyOpSchema) .kernel&lt;decltype(my_kernel_cpu), &amp;my_kernel_cpu&gt;() .dispatchKey(CPUTensorId());</p>
<p>Changes:</p><ul>
<li>isolate, i.e. remove dependencies on internal libstdc++ stuff</li>
<li>use c++17 behavior even in c++11 or c++14</li>
<li>remove std::swappable special case because that doesn't work with MSVC</li>
<li>constexpr more things</li>
<li>add some features like prepend/tail</li>
</ul>
<p>If using std::array at runtime, feel free to either keep using std::array or use this one - it doesn't really matter. For compile time computations, this one here is preferred because std::array in C++11 misses some constexpr specifiers, forcing these methods to be called at runtime instead of compile time.</p>
<p>Note that arithmetic operations are implemented by converting to floating point and performing the operation in float32, instead of using CUDA half intrinisics. Most uses of this type within ATen are memory bound, including the element-wise kernels, and the half intrinisics aren't efficient on all GPUs. If you are writing a compute bound kernel, you can use the CUDA half intrinsics directly on the <a class="el" href="structc10_1_1_half.html">Half</a> type from device code. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a42c3bec19efab8293c355543d1d3a230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacec10.html#a42c3bec19efab8293c355543d1d3a230">c10::DeviceIndex</a> = typedef int16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An index representing a specific device; e.g., the 1 in GPU 1. </p>
<p><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> DeviceIndex is not independently meaningful without knowing the DeviceType it is associated; try to use <a class="el" href="structc10_1_1_device.html" title="Represents a a compute device on which a tensor is located. ">Device</a> rather than DeviceIndex directly. </p>

<p>Definition at line <a class="el" href="c10_2core_2_device_8h_source.html#l00018">18</a> of file <a class="el" href="c10_2core_2_device_8h_source.html">Device.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab0b0cc3d46867de8f1fc3eb5b2b1f05b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using c10::KernelCacheCreatorFunction = typedef std::unique_ptr&lt;<a class="el" href="classc10_1_1_kernel_cache.html">c10::KernelCache</a>&gt; (</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of a user-supplied function to initialize the kernel cache. </p>
<p>this is stored together with the KernelFunction in the <a class="el" href="classc10_1_1_dispatch_table.html" title="Per-operator dispatch table. ">DispatchTable</a> so we can create a new cache instance when a kernel is looked up from the dispatch table. </p>

<p>Definition at line <a class="el" href="_dispatch_table_8h_source.html#l00026">26</a> of file <a class="el" href="_dispatch_table_8h_source.html">DispatchTable.h</a>.</p>

</div>
</div>
<a class="anchor" id="a86cf2f99dcc955e3b841db692c5b7102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacec10.html#a86cf2f99dcc955e3b841db692c5b7102">c10::KernelFunction</a> = typedef void(Stack*, <a class="el" href="classc10_1_1_kernel_cache.html">KernelCache</a>* cache)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the basic ABI for any kernel call. </p>
<p>Each kernel is registered as a function pointer <code>KernelFunction*</code>, i.e. kernels are not allowed to be closures. </p>

<p>Definition at line <a class="el" href="_kernel_function_8h_source.html#l00014">14</a> of file <a class="el" href="_kernel_function_8h_source.html">KernelFunction.h</a>.</p>

</div>
</div>
<a class="anchor" id="a303110250c2998ead3a7f1b0638158cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacec10.html#a303110250c2998ead3a7f1b0638158cb">c10::StreamId</a> = typedef int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An index representing a specific stream. </p>
<p><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> StreamId is not independently meaningful without knowing the <a class="el" href="structc10_1_1_device.html" title="Represents a a compute device on which a tensor is located. ">Device</a> it is associated with; try to use <a class="el" href="classc10_1_1_stream.html" title="A stream is a software mechanism used to synchronize launched kernels without requiring explicit sync...">Stream</a> rather than StreamId directly.</p>
<p>StreamIds are opaque; they are assigned by some DeviceType-specific numbering system which is not visible to the user. HOWEVER, we guarantee that StreamId 0 is always a valid stream, and corresponds to some sort of "default" stream. </p>

<p>Definition at line <a class="el" href="c10_2core_2_stream_8h_source.html#l00015">15</a> of file <a class="el" href="c10_2core_2_stream_8h_source.html">Stream.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ad64cdd76c7657cda0c865ef9e5992fd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacec10.html#ad64cdd76c7657cda0c865ef9e5992fd3">c10::Backend</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This legacy enum class defines the set of backends supported by old school, code generated Type-based ATen. </p>
<p>The reason we are sunsetting this enum class is because it doesn't allow for open registration of backends. <a class="el" href="classc10_1_1_tensor_type_id.html" title="Dynamic type ID of a Tensor argument. ">TensorTypeId</a> is the replacement for Backend which supports open registration.</p>
<p>ARE YOU SURE YOU WANT TO USE THIS TYPE? Think about if SparseCPU/SparseCUDA would make sense in your use case. If it doesn't make sense, maybe you want DeviceType. </p>

<p>Definition at line <a class="el" href="c10_2core_2_backend_8h_source.html#l00023">23</a> of file <a class="el" href="c10_2core_2_backend_8h_source.html">Backend.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a86a64d5723fb1713c8a3d8e546a561ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> c10::device </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structc10_1_1_device.html">Device</a>&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>device</code> set to the given one. </p>

<p>Definition at line <a class="el" href="c10_2core_2_tensor_options_8h_source.html#l00489">489</a> of file <a class="el" href="c10_2core_2_tensor_options_8h_source.html">TensorOptions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0fe14c970ecafbf1c875242c39128c5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> c10::device_index </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>device_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>device</code> set to CUDA and the <code>device_index</code> set to the given one. </p>

<p>Definition at line <a class="el" href="c10_2core_2_tensor_options_8h_source.html#l00495">495</a> of file <a class="el" href="c10_2core_2_tensor_options_8h_source.html">TensorOptions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a29c51d9aeae386461db374b6d76dec65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> c10::dtype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcaffe2_1_1_type_meta.html">caffe2::TypeMeta</a>&#160;</td>
          <td class="paramname"><em>dtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>dtype</code> set to the given one. </p>

<p>Definition at line <a class="el" href="c10_2core_2_tensor_options_8h_source.html#l00472">472</a> of file <a class="el" href="c10_2core_2_tensor_options_8h_source.html">TensorOptions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a71edc8f1f2dfaf2eed7d27d9536ae277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> c10::layout </td>
          <td>(</td>
          <td class="paramtype">Layout&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>layout</code> set to the given one. </p>

<p>Definition at line <a class="el" href="c10_2core_2_tensor_options_8h_source.html#l00483">483</a> of file <a class="el" href="c10_2core_2_tensor_options_8h_source.html">TensorOptions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a14f6ad44d4802580d666e93ba4fd6259"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc10_1_1_temp_file.html">TempFile</a> c10::make_tempfile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name_prefix</em> = <code>&quot;torch-file-&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Like <code>try_make_tempfile</code>, but throws an exception if a temporary file could not be returned. </p>

<p>Definition at line <a class="el" href="tempfile_8h_source.html#l00097">97</a> of file <a class="el" href="tempfile_8h_source.html">tempfile.h</a>.</p>

</div>
</div>
<a class="anchor" id="a01e4d7151bcdbf4f0c47179551ff65f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C10_EXPORT bool c10::ParseCommandLineFlags </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pargc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>pargv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the commandline flags. </p>
<p>This command parses all the commandline arguments passed in via pargc and argv. Once it is finished, partc and argv will contain the remaining commandline args that <a class="el" href="namespacec10.html" title="To register your own kernel for an operator, do in one (!) cpp file: C10_REGISTER_KERNEL(OperatorHand...">c10</a> does not deal with. Note that following convention, argv[0] contains the binary name and is not parsed. </p>

<p>Definition at line <a class="el" href="flags__use__no__gflags_8cpp_source.html#l00038">38</a> of file <a class="el" href="flags__use__no__gflags_8cpp_source.html">flags_use_no_gflags.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc2f14627a60d06b6d14c2339531798b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> c10::requires_grad </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requires_grad</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience function that returns a <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> object with the <code>requires_grad</code> set to the given one. </p>

<p>Definition at line <a class="el" href="c10_2core_2_tensor_options_8h_source.html#l00501">501</a> of file <a class="el" href="c10_2core_2_tensor_options_8h_source.html">TensorOptions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2abacacd5a4e4ef6ef00643e7fb4102e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C10_API void c10::SetAllocator </td>
          <td>(</td>
          <td class="paramtype">DeviceType&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structc10_1_1_allocator.html">Allocator</a> *&#160;</td>
          <td class="paramname"><em>alloc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the allocator for DeviceType <code>t</code>. </p>
<p>The passed in allocator pointer is expected to have static lifetime; this function does NOT take ownership of the raw pointer. (The reason for this is to prevent existing pointers to an allocator of a particular device from being invalidated when SetAllocator is called.)</p>
<p>Also note that this is not thread-safe, and we assume this function will only be called during initialization. </p>

<p>Definition at line <a class="el" href="_allocator_8cpp_source.html#l00021">21</a> of file <a class="el" href="_allocator_8cpp_source.html">Allocator.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a01a77b8ab825db155ab44df79e49a25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C10_API void c10::ShowLogInfoToStderr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> utility to allow one to show log info to stderr after the program starts. </p>
<p>This is similar to calling GLOG's &ndash;logtostderr, or setting caffe2_log_level to smaller than INFO. You are recommended to only use this in a few sparse cases, such as when you want to write a tutorial or something. Normally, use the commandline flags to set the log level. </p>

<p>Definition at line <a class="el" href="_logging_8cpp_source.html#l00182">182</a> of file <a class="el" href="_logging_8cpp_source.html">Logging.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38754f58b3aa8b69daecd7a0c3d34d5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structc10_1_1_tensor_options.html">c10::TensorOptions</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t.html">T</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_a.html" title="does bound shape inference given a C2 net. ">A</a> class to encapsulate construction axes of an <a class="el" href="struct_tensor.html">Tensor</a>. </p>
<p><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> was designed to support the Python style API for specifying construction options on factory functions, e.g., </p><pre class="fragment">torch.zeros(2, 3, dtype=torch.int32)
</pre><p>Because C++ doesn't natively support keyword arguments, there must be another way of specifying keyword-like arguments. <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> is a builder class which can be used to construct this "dictionary" of keyword arguments: functions which support <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> conventionally take this argument optionally as their last argument.</p>
<p>WARNING: In PyTorch, there are <code>torch::</code> variants of factory functions, e.g., torch::zeros for at::zeros. These return Variables (while the stock ATen functions return plain Tensors). If you mix these functions up, you WILL BE SAD.</p>
<p>Rather than use the constructor of this class directly, you should prefer to use the constructor functions, and then chain setter methods on top of them. </p><pre class="fragment">at::device(at::kCUDA).dtype(kInt)
at::dtype(at::kInt)
</pre><p>Additionally, anywhere a <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> is expected, you can directly pass at::kCUDA / at::kInt, and it will implicitly convert to a <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>.</p>
<p>Here are some recommended ways to create a 2x2 tensor of zeros with certain properties. These all <em>implicitly</em> make use of <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a>, even if they don't mention the class explicitly: </p><pre class="fragment">at::zeros({2,2}, at::kCUDA);
at::zeros({2,2}, at::kLong);
at::zeros({2,2}, at::device(at::kCUDA).dtype(at::kLong()));
at::zeros({2,2}, at::device({at::kCUDA, 1})); // place on device 1
at::zeros({2,2}, at::requires_grad());</pre><p> NOTE [ <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> Constructors ]</p>
<p><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> is like a dictionary with entries from the set: {requires_grad, is_variable, device, dtype, layout}, where each entry may be unspecified (i.e., is optional). It is used to specify the properties of tensors in many places both in C++ internal and API, e.g., tensor factory methods like <code>at::empty({10}, options)</code>, tensor conversions like <code>tensor.to(...)</code>, etc.</p>
<p>To provide a simple API that is consistent with Python, where one can do <code>torch.empty(sizes, X)</code> with <code>X</code> being a <code>torch.device</code>, <code>torch.dtype</code>, or a <code>torch.layout</code>, we want <a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a> to be implicitly convertible from <code>ScalarType dtype</code>, <code>Layout layout</code> and <code><a class="el" href="structc10_1_1_device.html" title="Represents a a compute device on which a tensor is located. ">Device</a> device</code>. Therefore, we have three implicit constructors from each of these three types.</p>
<p>This is sufficient for <code>ScalarType</code> and <code>Layout</code> as they are simple Enum classes. However, <code><a class="el" href="structc10_1_1_device.html" title="Represents a a compute device on which a tensor is located. ">Device</a></code> is an ordinary class with implicit constructors <code><a class="el" href="structc10_1_1_device.html" title="Represents a a compute device on which a tensor is located. ">Device</a>(DeviceType, DeviceIndex = -1)</code> and <code>Device(std::string)</code> to be consistent with Python API, where strings are treated as equivalent with a <code>torch.device</code> object (e.g., "cuda:1" can be passed to everywhere a <code>torch.device("cuda:1")</code> is accepted). To support the syntax <code>at::empty({10}, {kCUDA, 1})</code> and <code>tensor.to(kCUDA)</code>, we need to make sure that <code><a class="el" href="structc10_1_1_tensor_options.html">TensorOptions</a></code> is implicitly constructible with any argments that a <code><a class="el" href="structc10_1_1_device.html" title="Represents a a compute device on which a tensor is located. ">Device</a></code> can constructed from. So we have,</p>
<p>/* implicit </p>

<p>Definition at line <a class="el" href="c10_2core_2_tensor_options_8h_source.html#l00080">80</a> of file <a class="el" href="c10_2core_2_tensor_options_8h_source.html">TensorOptions.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad0a54dde60c980b594d86c402ebd3e7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classc10_1_1optional.html">c10::optional</a>&lt;<a class="el" href="structc10_1_1_temp_file.html">TempFile</a>&gt; c10::try_make_tempfile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name_prefix</em> = <code>&quot;torch-file-&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to return a temporary file or returns <code>nullopt</code> if an error ocurred. </p>
<p>The file returned follows the pattern <code>&lt;tmp-dir&gt;/&lt;name-prefix&gt;&lt;random-pattern&gt;</code>, where <code>&lt;tmp-dir&gt;</code> is the value of the <code>"TMPDIR"</code>, <code>"TMP"</code>, <code>"TEMP"</code> or <code>"TEMPDIR"</code> environment variable if any is set, or otherwise <code>/tmp</code>; <code>&lt;name-prefix&gt;</code> is the value supplied to this function, and <code>&lt;random-pattern&gt;</code> is a random sequence of numbers. On Windows, <code>name_prefix</code> is ignored and <code>tmpnam</code> is used. </p>

<p>Definition at line <a class="el" href="tempfile_8h_source.html#l00081">81</a> of file <a class="el" href="tempfile_8h_source.html">tempfile.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a81ad47b27779369969cc5074beb920a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* * * But this will be problematic Consider * Compiler will compain about ambiguity between the copy constructor and the* <a class="el" href="structc10_1_1_device.html">Device</a> constructor c10::because</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{kCUDA, 1}` can be converted to both a</div><div class="line"> *  `TensorOption` and a `Device`.</div><div class="line"> * </div><div class="line"> *  To <span class="keyword">get</span> around <span class="keyword">this</span></div></div><!-- fragment -->
<p>Definition at line <a class="el" href="c10_2core_2_tensor_options_8h_source.html#l00092">92</a> of file <a class="el" href="c10_2core_2_tensor_options_8h_source.html">TensorOptions.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a856f57c37775d4151690b34804dc50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int c10::COMPILE_TIME_MAX_DEVICE_TYPES</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(DeviceType::COMPILE_TIME_MAX_DEVICE_TYPES)</div></div><!-- fragment -->
<p>Definition at line <a class="el" href="_device_type_8h_source.html#l00035">35</a> of file <a class="el" href="_device_type_8h_source.html">DeviceType.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 21 2019 13:06:25 for Caffe2 - C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<div class="footerContainer">
  <div id="footer_wrap" class="wrapper footerWrapper">
    <div class="footerBlocks">
      <div id="fb_oss" class="footerSection fbOpenSourceFooter">
          <svg class="facebookOSSLogoSvg" viewBox="0 0 1133.9 1133.9" x="0px" y="0px" height=50 width=50>
            <g>
              <path class="logoRing outerRing" d="M 498.3 3.7 c 153.6 88.9 307.3 177.7 461.1 266.2 c 7.6 4.4 10.3 9.1 10.3 17.8 c -0.3 179.1 -0.2 358.3 0 537.4 c 0 8.1 -2.4 12.8 -9.7 17.1 c -154.5 88.9 -308.8 178.1 -462.9 267.5 c -9 5.2 -15.5 5.3 -24.6 0.1 c -153.9 -89.2 -307.9 -178 -462.1 -266.8 C 3 838.8 0 833.9 0 825.1 c 0.3 -179.1 0.2 -358.3 0 -537.4 c 0 -8.6 2.6 -13.6 10.2 -18 C 164.4 180.9 318.4 92 472.4 3 C 477 -1.5 494.3 -0.7 498.3 3.7 Z M 48.8 555.3 c 0 79.9 0.2 159.9 -0.2 239.8 c -0.1 10 3 15.6 11.7 20.6 c 137.2 78.8 274.2 157.8 411 237.3 c 9.9 5.7 17 5.7 26.8 0.1 c 137.5 -79.8 275.2 -159.2 412.9 -238.5 c 7.4 -4.3 10.5 -8.9 10.5 -17.8 c -0.3 -160.2 -0.3 -320.5 0 -480.7 c 0 -8.8 -2.8 -13.6 -10.3 -18 C 772.1 218 633.1 137.8 494.2 57.4 c -6.5 -3.8 -11.5 -4.5 -18.5 -0.5 C 336.8 137.4 197.9 217.7 58.8 297.7 c -7.7 4.4 -10.2 9.2 -10.2 17.9 C 48.9 395.5 48.8 475.4 48.8 555.3 Z" />
              <path class="logoRing middleRing" d="M 184.4 555.9 c 0 -33.3 -1 -66.7 0.3 -100 c 1.9 -48 24.1 -86 64.7 -110.9 c 54.8 -33.6 110.7 -65.5 167 -96.6 c 45.7 -25.2 92.9 -24.7 138.6 1 c 54.4 30.6 108.7 61.5 162.2 93.7 c 44 26.5 67.3 66.8 68 118.4 c 0.9 63.2 0.9 126.5 0 189.7 c -0.7 50.6 -23.4 90.7 -66.6 116.9 c -55 33.4 -110.8 65.4 -167.1 96.5 c -43.4 24 -89 24.2 -132.3 0.5 c -57.5 -31.3 -114.2 -64 -170 -98.3 c -41 -25.1 -62.9 -63.7 -64.5 -112.2 C 183.5 621.9 184.3 588.9 184.4 555.9 Z M 232.9 556.3 c 0 29.5 0.5 59.1 -0.1 88.6 c -0.8 39.2 16.9 67.1 50.2 86.2 c 51.2 29.4 102.2 59.2 153.4 88.4 c 31.4 17.9 63.6 18.3 95 0.6 c 53.7 -30.3 107.1 -61.2 160.3 -92.5 c 29.7 -17.5 45 -44.5 45.3 -78.8 c 0.6 -61.7 0.5 -123.5 0 -185.2 c -0.3 -34.4 -15.3 -61.5 -44.9 -79 C 637.7 352.6 583 320.8 527.9 290 c -27.5 -15.4 -57.2 -16.1 -84.7 -0.7 c -56.9 31.6 -113.4 64 -169.1 97.6 c -26.4 15.9 -40.7 41.3 -41.1 72.9 C 232.6 491.9 232.9 524.1 232.9 556.3 Z" />
              <path class="logoRing innerRing" d="M 484.9 424.4 c 69.8 -2.8 133.2 57.8 132.6 132 C 617 630 558.5 688.7 484.9 689.1 c -75.1 0.4 -132.6 -63.6 -132.7 -132.7 C 352.1 485 413.4 421.5 484.9 424.4 Z M 401.3 556.7 c -3.4 37.2 30.5 83.6 83 84.1 c 46.6 0.4 84.8 -37.6 84.9 -84 c 0.1 -46.6 -37.2 -84.4 -84.2 -84.6 C 432.2 472.1 397.9 518.3 401.3 556.7 Z" />
            </g>
          </svg>
        <h2>Facebook Open Source</h2>
      </div>
      <div class="footerSection">
        <a class="footerLink" href="https://code.facebook.com/projects/" target="_blank">Open Source Projects</a>
        <a class="footerLink" href="https://github.com/facebook/" target="_blank">GitHub</a>
        <a class="footerLink" href="https://twitter.com/fbOpenSource" target="_blank">Twitter</a>
      </div>
      <div class="footerSection rightAlign">
        <a class="footerLink" href="https://github.com/caffe2/caffe2" target="_blank">Contribute to this project on GitHub</a>
      </div>
    </div>
  </div>
</div>
<script type="text/javascript" src="/js/jekyll-link-anchors.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', '{{ site.gacode }}', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
